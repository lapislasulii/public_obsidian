

## I. Архитектура интерпретатора CPython

**1. Гибридная система** Python часто классифицируется как интерпретируемый язык высокого уровня. Интерпретируемые языки отличаются от компилируемых тем, что трансляция кода в команды, понятные компьютеру, происходит прямо во время исполнения. На самом деле, эта классификация является сильным упрощением, поскольку Python (в реализации **CPython**, написанной на C) — это **гибридная система**. Она включает в себя полный компилятор (как у C++ или Java) и стековую виртуальную машину (PVM), которая создает иллюзию построчного исполнения.

**2. Этапы преобразования кода** Запуск Python-скрипта инициирует сложную цепочку преобразований данных:

1. **Исходный код** (текстовый файл UTF-8).
2. **Токены/Лексемы** (условные слова).
3. **Абстрактное синтаксическое дерево (АСТ)** — представление связей между лексемами.
4. **Байткод** (компилируется).
5. **Исполнение**.

Архитектуру CPython можно разделить на два больших блока: **Компилятор** и **Виртуальная машина (PVM)**.

## III. Стадии работы Компилятора

Компилятор принимает исходный текст, выполняет статистический анализ и трансляцию, и в результате выдает объект кода (`PyCodeObject`).

### 1. Сканирование (Лексический анализ)

- **Задача:** Преобразовать бесструктурный поток символов (исходный текст) в поток атомарных элементов, называемых **токенами** или лексемами (отдельные слова, такие как `if`, `else`, `for`, `while`).
- **Обработка отступов:** Ключевая особенность Python. Сканер преобразует текст в конечный автомат. На основе отступов определяются переходы между состояниями. Если уровень отступа новой строки больше предыдущего, генерируется токен `INDENT`, если меньше — `DEDENT`. Это позволяет парсеру на следующем этапе воспринимать структуру как плоский поток.
- **Типы токенов:** Включают имена, стринги, newлайны, числа, инденты и операторы (`OP`).
- **Инструменты:** Встроенный модуль `tokenize` позволяет увидеть, как интерпретатор видит код перед парсингом.
- **Ошибки:** На уровне лексера уже видны простейшие ошибки, например, `IndentationError` или незакрытые скобки.

### 2. Синтаксический анализ (Парсинг)

- **Задача:** Проверить, образуют ли токены допустимые конструкции языка.
- **Результат:** **Абстрактное синтаксическое дерево (АСТ)** — структура данных, отображающая логическую структуру программы, отбрасывая несущественные детали синтаксиса (например, двоеточия).
- **Механизмы:** До Python 3.9 использовался LL(1) парсер, который строил CST (Concrete Syntax Tree). Начиная с Python 3.9, Python использует PEG (Parsing Expression Grammar).
- **Структура АСТ:** Узлы АСТ определены в файле `Python.ASDL`. Каждый узел — это экземпляр класса, наследуемого от `ast.AST`.
- **Пример узла:** Для кода `X = 42` узел `Assign` имеет атрибут `target` (узел `Name`) и `value`. Важный атрибут `CTX` (контекст) показывает, происходит ли чтение переменной или запись в нее.
- **Метапрограммирование:** Модуль `ast` позволяет не только анализировать, но и модифицировать код на лету. Этот механизм лежит в основе таких инструментов, как `pytest` (переписывание функций `assert` для детальных отчетов) и линтеры.

### 3. Фаза Компиляции в Байткод

Компиляция превращает АСТ в последовательность инструкций, которые выполняет виртуальная машина. Этот процесс включает несколько проходов по дереву.

#### A. Таблицы символов (Symbol Tables)

Перед генерацией инструкций компилятор разбирается с областями видимости (lexical scoping). Для каждого блока (модуль, класс, функция) создается запись в таблице символов. На основе анализа присваивания и использования переменным присваивается роль:

- **`LOCAL`** (внутри функции).
- **`GLOBAL`** (на уровне модуля или явно объявленная как `global`).
- **`NONLOCAL`** (из внешней охватывающей функции, используется в замыканиях).
- **`FREE`** (используется в текущей функции, но определена в охватывающей). Разные роли критически важны, так как для доступа используются разные конструкции байткода, имеющие разную производительность (например, `LOAD_FAST` для локальных быстрее, чем `LOAD_GLOBAL` по хэш-таблице).

#### B. Control Flow Graph (CFG)

После построения таблицы символов начинается генерация байткода.

- Компилятор обходит АСТ и организует действия в блоки (одна точка входа и одна точка выхода), внутри которых нет ветвлений. Ветвления соединяют блоки друг с другом.
- Использование CFG позволяет компилятору абстрагироваться от конкретных адресов переходов, что обеспечивает динамичную природу языка. Инструкции прыжков ссылаются на целевые блоки, а не на байтовые смещения.

#### C. Сборка (Ассемблирование)

На этой финальной стадии CFG линеаризуется (сплющивается) в линейный алгоритм. Рассчитываются конкретные смещения для абстрактных ссылок.

- **Оптимизация:** На этом этапе работает оптимизатор **IP** (Intra-procedural peekhole optimizer), который просматривает граф и удаляет те ноды (блоки кода), по которым проход никогда не произойдет, например, код после оператора `return`.

### 4. Объект кода и кэширование

- **PyCodeObject:** Результатом работы компилятора является объект кода (тип `code` в Python) — неизменяемая, самодостаточная структура на C, содержащая все необходимое для выполнения скомпилированного блока.
- **Поля `PyCodeObject`:** Включает строку с инструкциями (`co_code`), константы (вынесенные за пределы графа), кортежи с локальными/глобальными именами переменных и размер стека.
- **Кэширование:** Результат компиляции кэшируется в файлах с расширением `.pyc` в директории `__pycache__`. Это сериализованный байткод, который идет в PVM для исполнения. Если исходный код не меняется, CPython пропускает фазу компиляции и загружает готовый байткод, что существенно сокращает время старта приложения.
- **Дезассемблирование:** Байткод представляет собой последовательность байтиков, где каждая инструкция (с версии 3.6) занимает 2 байта (1 байт на opcode, 1 на аргумент). Модуль `disassembler` (`dis`) позволяет перевести этот бинарный поток обратно в читаемый вид.
- **Сравнение производительности:** Анализ байткода объясняет, почему **list comprehensions** работают быстрее обычных циклов `for`, поскольку используют прямой цикл и `find_append` на уровне байткода, который компилируется.

## IV. Виртуальная машина Python (PVM)

**1. Исполнение кода** Виртуальная машина (PVM) принимает объект кода и исполняет его. PVM — это просто бесконечный цикл, который берет байтики байткода и выполняет их по очереди, работая с памятью и состоянием кода. PVM является **стековой машиной** (в отличие от регистровых архитектур X86), что упрощает реализацию, но требует больше инструкций для базовых операций.

**2. Три стека PVM** Понимание PVM невозможно без понимания трех стеков, которые она использует:

1. **Call Stack (Стек вызовов):** Хранит цепочку активных фреймов. Новый фрейм создается и помещается на этот стек при вызове функции.
2. **Evaluation Stack (Стек вычислений):** Находится внутри каждого фрейма. С ним работают все инструкции байткода (например, операция `BINARY_ADD` берет два верхних элемента, складывает их и кладет результат обратно на стек).
3. **Block Stack (Стек блоков):** Использовался до Python 3.11 для управления вложенными блоками кода, но сейчас его функциональность перешла к Call Stack.

**3. Фрейм (PyFrameObject)** `PyFrameObject` является единицей контекста выполнения и хранится на **куче** (heap), а не на системном стеке C. Это фундаментальное решение позволяет реализовать генераторы и корутины, поскольку фрейм может пережить вызов функции, которая его создала (т.е. заморозить свое состояние и восстановить его позже). Фрейм содержит ссылку на предыдущий фрейм, ссылку на объект кода, массив локальных переменных и индекс последней выполненной инструкции.

**4. Цикл PVM и GIL** Сердцем PVM является функция `PyEval_Frame_Default` (в файле `ceval.c`), представляющая собой цикл `while(true)` с оператором `switch` для описания операций. Внутри этого цикла происходит управление **GIL (Global Interpreter Lock)**. Интерпретатор периодически (по умолчанию каждые 5 микросекунд, ранее каждые 100 инструкций) освобождает GIL, чтобы дать другим потокам время исполниться.

## V. Оптимизации (Python 3.11 и выше)

Последние лекции семестра посвящены оптимизации производительности. Начиная с Python 3.11, в CPython были внедрены важные оптимизации.

**1. Специализированный адаптивный интерпретатор (Fast Python)** Эта система использует адаптивную интерпретацию:

- **Прогрев (Warmup):** Изначально байткод содержит общие инструкции (например, `BINARY_OP`), и интерпретатор ведет счетчик запусков.
- **Специализация:** Когда счетчик превышает порог, интерпретатор анализирует типы операндов. Если он видит, что операнды всегда одного типа (например, всегда `int`), он "на лету" **заменяет общую инструкцию** в байткоде на специализированную (e.g., для сложения целых чисел). Специализированные инструкции работают быстрее, так как не тратят время на проверки типов.
- **Деоптимизация:** Если типы операндов меняются, специализированная инструкция заменяется обратно на общую.
- Для хранения информации о типах используются встроенные кэши (`inline caches`), из-за чего формат байткода меняется (за инструкциями следуют специальные слоты).

**2. Zero Cost Exceptions (Исключения с нулевыми издержками)** С Python 3.11 была изменена логика обработки исключений:

- Был удален стек блоков для исключений, и вход в блок `try` стал "бесплатным" (не содержит никаких инструкций, которые тратят процессорное время).
- Компилятор генерирует статическую **таблицу исключений** (`exception table`). Когда возникает исключение, PVM ищет в этой таблице адрес обработчика и прыгает туда.
- Если исключений нет, программа работает так, как будто блоков `try` не существует, что дает значительный прирост производительности.

**Заключение** Архитектура CPython является многослойной системой, намного более сложной, чем простая интерпретация. Понимание работы лексера, парсера, компилятора и виртуальной машины трансформирует подход к разработке и помогает оптимизировать производительность кода.