### I. Проблема динамической типизации и три столпа надежности

В начале изучения языка Python одним из его основных конкурентных преимуществ называлась **динамическая типизация**. Это означает, что разработчику не нужно самостоятельно следить за типами данных; интерпретатор делает это за него.

Однако, за эту "радость" приходится платить **скоростью разработки** и тем, что результат не обязательно будет **консистентным** (согласованным).

**Пример проблемы:** Очень простой код, который складывает числа (ожидает `int`), может работать в продакшене годами. Но если пользователь передаст в него строку вместо числа (например, число в кавычках), возникнет `TypeError`. Ошибка будет звучать как `unsupported operand types` (неподдерживаемые типы операндов).

Тема лекции — **сознательное ограничение динамичности** в пользу **стабильности** работы программного продукта. Правило гласит: если пользователь может сделать с кодом что-нибудь глупое, он обязательно это сделает.

Три темы (три столпа надежности в мире Python), о которых шла речь:

1. **Правила корректности (Type Annotations):** Как ловить ошибки до запуска кода (статический анализ).
2. **Стабильность (Dependency Management):** Как избежать "Dependency Hell".
3. **Интроспекция:** Как сделать код гибким и адаптивным к "человеческой глупости".

### II. Аннотация типов (Type Annotations)

Аннотация типов, также известная как **gradual typing** (постепенная типизация), позволяет добавить в динамический Python элементы статической типизации.

#### 1. Статическая vs. Динамическая Типизация

- **Статическая типизация:** Типы известны на этапе компиляции (compile time). Компилятор (например, в C++, Java, GO) проверяет код до запуска, и при несоответствии типов программа не скомпилируется.
- **Динамическая типизация:** Типы связываются со значениями во время исполнения (runtime). Интерпретатор (Python, JavaScript) проверяет типы только в момент выполнения операции.

#### 2. Роль аннотаций

Интерпретатор Python, по большому счету, **игнорирует** аннотации. Они нужны как **подсказки (хинт)** для **синтаксических анализаторов** (внешних инструментов, таких как MyPy). Статический анализатор может подсветить ошибки (`incompatible types in assignment`) до запуска кода.

#### 3. Преимущества аннотаций

- **Статический анализ:** Предоставление внешним инструментам данных для определения потенциальных проблем.
- **Поддержка в IDE:** Интегрированные среды разработки (PyCharm, VS Code) используют аннотации для выдачи корректных подсказок, автодополнения и ускорения написания кода.
- **Документация:** Типизация является лучшей документацией к коду, описывая, что функция ожидает на вход и что отдает на выход.
- **Валидация:** Используется современными фреймворками (FastAPI, Pydantic) для валидации данных.

#### 4. Базовый синтаксис

- **Функции (PEP 484):** Тип параметра указывается через двоеточие (`:`), а тип возвращаемого значения (return type) — через стрелочку (`->`).
    - Если функция не возвращает никакого значения (по умолчанию возвращается `None`), прописывается `-> None`.
- **Переменные (более свежий PEP):** `variable_name: type = value`. Этот синтаксис позволяет декларировать переменные без немедленной инициализации.
- **Рекомендуемый стиль (PEP):** Двоеточие без пробела до, один пробел после.

#### 5. Сложные типы и ограничения

- **Классовые переменные:** Используется `ClassVar`, импортированный из `typing`, чтобы пометить переменную, относящуюся к классу, а не к его экземпляру.
- **Наследие коллекций:** В старых версиях Python для аннотирования коллекций (списков, словарей) использовались примитивы `List`, `Dict`, `Set` из модуля `typing`. Это считается устаревшим.
- **Союзы типов (Union) и Опциональные типы (Optional):**
    - `Union[Type1, Type2]` используется, если переменная может иметь несколько типов.
    - `Optional[Type]` — это сокращение для `Union[Type, None]`.
- **Вызываемые (Callable) и Любые (Any):**
    - `Callable` используется для аннотирования функций, передаваемых в качестве аргументов.
    - `Any` **отключает проверку типов полностью**. Использование `Any` не рекомендуется, так как оно обладает свойством "заразительности" (виральности): любой тип, который взаимодействует с объектом, аннотированным как `Any`, также теряет все проверки.
- **Современный синтаксис (Python 3.9+):** Коллекции аннотируются напрямую, используя малую букву (например, `list[str]`), без импорта из `typing`.
- **Оператор вертикальной черты (`|`):** Шорткат для `Union` и `Optional`. Например, `int | str` эквивалентно `Union[int, str]`, а `str | None` эквивалентно `Optional[str]`.

#### 6. TypeVar и Generics

Для решения проблемы сохранения информации о типе, когда функция должна принимать и возвращать объект _любого_ типа, используется **Type Variable (TypeVar)**.

- `TypeVar` создает связь между типом входного параметра и типом возвращаемого значения. Он пропускает любой тип, но сохраняет информацию о том, какой именно тип был использован.
- **Generics (Дженерики)** — это кастомные объекты (классы), аннотированные с использованием `TypeVar`. Они позволяют определить класс (например, стек), который может работать с разными типами данных (интами или строками), но при этом MyPy может поймать ошибку, если в стек интов попытаться добавить строку.
- **Ограничение TypeVar:** `TypeVar` можно ограничить определенным набором типов или подклассами родительского класса с помощью параметра `bound`.

#### 7. Протоколы (Protocols)

Протоколы реализуют концепцию **статической "утиной" типизации (structural typing)**.

- **"Утиная типизация" (Duck Typing):** Питон интересуется не точным типом объекта, а тем, какими методами он обладает.
- **Протокол:** Определяет ожидаемую структуру (набор методов), не требуя явного наследования.
- Протоколы импортируются из модуля `typing`.
- **Преимущество перед ABC (Abstract Base Class):** ABC требует явного наследования (номинальная типизация). Протоколы не требуют наследования; достаточно, чтобы объект обладал нужными методами (например, `make_sound`). Это полезно, когда множество несвязанных классов используют общую логику (например, метод `read`).

### III. Статический анализатор MyPy

**MyPy** — это внешний модуль (линтер), который используется для проверки типизации, основанной на аннотациях.

#### 1. Работа MyPy

MyPy запускается над файлом командой `mypy filename.py`. Он заранее определяет, что код не заработает, выдавая `Type error` до его исполнения.

Вывод MyPy указывает:

- В каком файле и на какой строке возникла ошибка.
- Информацию о проблеме (например, ожидание строки, получение `integer`).

MyPy также отслеживает попытки сослаться на **`None`** и опечатки в атрибутах.

#### 2. Настройка MyPy

По умолчанию MyPy считает все объекты `Any` и неэффективен. Для строгой проверки требуется конфигурационный файл `mypy.ini`.

Основные строгие флаги:

- `disallow_untyped_defs = True`: Запрещает функции без аннотаций.
- `strict_optional = True`: Запрещает толерантность к `None`.
- Можно использовать команду `mypy --strict` для ввода самых строгих ограничений.

#### 3. Сужение типа (Type Narrowing)

Чтобы исправить ситуации, когда переменная может быть `None` (или иметь несколько типов), используется `type narrowing` — сужение типа в рамках блока кода (например, с помощью `if isinstance(data, int)`).

#### 4. Резюме по MyPy

MyPy — это "первый код-ревью менеджер", который ловит **90% глупых ошибок** до того, как они попадут в ваш код. Проверки MyPy должны быть настроены в **строгом режиме (strict)**.

### IV. Контроль зависимостей (Dependency Management)

Проблема, от которой страдает Python — это **Dependency Hell**. Это ситуация, когда невозможно установить или обновить пакет, поскольку два других пакета требуют разные несовместимые версии одной и той же транзитивной зависимости. Это называется **Diamond Dependency Problem**.

#### 1. Классический (Legacy) подход

Использование **Virtual Environment (Venv)** и пакетного менеджера **PIP**. Декларативный документ — `requirements.txt`, который часто генерируется командой `pip freeze`.

Недостатки `requirements.txt`:

- Сложно отделить транзитивные зависимости от тех, которые внесены разработчиком.
- Невозможно разделить зависимости для разработки (Dev) и эксплуатации (Prod) (например, `pytest` нужен только при разработке).
- Сборка **не детерминирована** (если версии указаны не строго, например, `requests > 2.0`).

#### 2. Альтернатива (Pipenv)

**Pipenv** (от Python Packaging Authority) объединяет PIP и Venv.

- Использует `Pipfile` (человекочитаемый) и `Pipfile.lock` (машинночитаемый, с хэшами) для детерминированной сборки.
- Позволяет разделить `packages` и `dev-packages`.
- Pipenv **не прижился**, поскольку не решал корневую проблему разрешения конфликтов транзитивных зависимостей.

#### 3. Современный стандарт (Poetry)

**Poetry** — де-факто стандарт, объединяющий Venv и PIP.

- Использует конфигурационные файлы `poetry.lock` и `pyproject.toml`.
- **Ключевое преимущество:** Poetry является **build-системой**, которая проверяет и **разрешает** транзитивные зависимости, пытаясь найти версию пакета, совместимую со всеми требованиями.
- Poetry — единый инструмент для всего жизненного цикла проекта, что делает его быстрее и эффективнее.

### V. Интроспекция кода (Introspection)

**Интроспекция** — это возможность программы знать о своем собственном устройстве, находя типы, структуры, атрибуты и методы объектов во время рантайма. Это сильная сторона Python, благодаря его динамической природе и тезису "все есть объект".

#### 1. Базовые инструменты интроспекции

- `type()`: Проверяет **точный тип** объекта.
- `isinstance()`: Более "умный" чекер; проверяет, является ли объект **экземпляром** данного класса, включая его родителей в иерархии наследования. Может проверять на соответствие сразу нескольким типам.
- `dir()`: Показывает, какими атрибутами обладает объект.
- `hasattr()`: Проверяет существование конкретного атрибута.
- `getattr()`: Возвращает атрибут по имени.
- `callable()`: Проверяет, может ли объект быть вызван как функция.
- `issubclass()`: Проверяет, связанны ли два объекта в иерархии наследования.

#### 2. Модуль `inspect`

Модуль `inspect` — "тяжелая артиллерия" для интроспекции.

Возможности:

- `getsource()`: Возвращает исходный код функции или класса.
- `getdoc()`: Возвращает документацию из docstrings.
- Анализ классов и функций, просчет стека вызовов.
- **Самый важный инструмент:** `signature()`.

**`inspect.signature()`** дает структурированную информацию об аргументах, типах и значениях по умолчанию функции, служа "рентгеном для функций". Это позволяет коду адаптировать логику (например, через `if-else`) к нештатным ситуациям или отсутствию ожидаемых параметров.

---

В целом, лекция была посвящена переходу от полной динамичности Python к управляемой надежности, используя аннотации для статического анализа и интроспекцию для самоадаптации кода.

> Защита от дурака в программировании похожа на проектирование автомобиля: динамичный и быстрый двигатель (динамическая типизация) дает свободу, но без ремней безопасности (аннотации и MyPy) и системы контроля сцепления (управление зависимостями) любой неопытный водитель (пользователь) может быстро попасть в аварию (`TypeError` или `Dependency Hell`). Интроспекция же позволяет машине самой понять, что водитель делает что-то не так, и скорректировать свое поведение.