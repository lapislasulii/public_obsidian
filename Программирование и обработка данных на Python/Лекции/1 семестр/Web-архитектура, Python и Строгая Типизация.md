
## Подробный конспект лекции: Web-архитектура, Python и Строгая Типизация

### I. Основы Web-архитектуры и Протокол HTTP

#### 1. Клиент-Серверная Архитектура

Веб-разработка основана на фундаментальной **клиент-серверной модели**.

- **Клиент (Client):** Программный инициатор (браузер, мобильное приложение, или другой сервер). Формирует чёткий, понятный запрос и отправляет его в сеть.
- **Сервер (Server):** Мощный компьютер, работающий 24/7. Исполняет инструкции, хранит файлы, базы данных и логику (например, Python-код).
- **Сеть (Network):** Среда передачи, соединяющая клиента и сервер.

#### 2. Цикл «Запрос-Ответ» (The Request-Response Cycle)

Это ключевая механика взаимодействия, состоящая из семи шагов:

1. **User Action:** Пользователь вводит URL в браузере.
2. **DNS Lookup:** Разрешение доменного имени в IP-адрес.
3. **TCP Handshake:** Установление соединения.
4. **HTTP Request:** Отправка сообщения на сервер.
5. **Processing:** Исполнение Python-кода на удалённом сервере.
6. **Response:** Сервер возвращает данные.
7. **Rendering:** Браузер отображает полученный контент.

#### 3. Протокол HTTP

**HTTP (Hypertext Transfer Protocol)** — это универсальный язык веб-коммуникации, набор жёстких правил и **ограничений** для формата сообщений.

- **Аналогия:** Клиент — Customer, API — Menu (контракт), HTTP — Waiter (официант), Сервер — Kitchen (кухня).

**Структура сообщения HTTP:**

|Сообщение|Start Line/Status Line|Headers (Заголовки)|Body (Тело)|
|:-:|:-:|:-:|:-:|
|**Request (Запрос)**|Метод + URL|Метаданные (auth token, language, format)|Опциональная полезная нагрузка (form data)|
|**Response (Ответ)**|Протокол + Код статуса|Метаданные (Content type, server info)|Фактический контент (HTML, JSON, image)|

#### 4. HTTP Методы и Идемпотентность

**Идемпотентность** — свойство операции, которая, будучи повторена, не изменяет результат после первого применения.

|Метод|Операция|Идемпотентность|
|:-:|:-:|:-:|
|**GET**|Получение данных (Retrieve)|Идемпотентен, безопасен|
|**POST**|Создание нового ресурса (Create)|**Не идемпотентен** (Пример: двойное нажатие "Оплатить" может привести к двум списаниям)|
|**PUT**|Замена всего ресурса (Replace)|Идемпотентен|
|**PATCH**|Частичное обновление|Обычно не идемпотентен|
|**DELETE**|Удаление ресурса (Remove)|Идемпотентен (Пример: второй запрос вернет 404, но состояние системы не изменится)|

#### 5. HTTP Статус-коды (Server Feedback)

- **2xx: Success (Успех)**:
    - **200 OK:** Стандартный успех.
    - **201 Created:** Успешное создание нового ресурса (типичный ответ для POST).
    - **204 No Content:** Успех, но нет тела ответа (часто после DELETE).
- **3xx: Redirection (Перенаправление)**:
    - **301 Moved Permanently:** Адрес сменился навсегда.
    - **304 Not Modified:** Кэшированная версия актуальна (критично для производительности).
- **4xx: Client Errors (Ошибки Клиента)**:
    - **400 Bad Request:** Синтаксическая ошибка в запросе.
    - **401 Unauthorized:** Требуется аутентификация.
    - **403 Forbidden:** Нет прав доступа.
    - **404 Not Found:** Ресурс не существует.
    - **429 Too Many Requests:** Превышен лимит скорости запросов.
- **5xx: Server Errors (Ошибки Сервера)**:
    - **500 Internal Server Error:** Необработанное исключение в Python-коде.
    - **502 Bad Gateway:** Ошибка коммуникации между серверами.
    - **503 Service Unavailable:** Сервер перегружен или на обслуживании.
    - **504 Gateway Timeout:** Сервер слишком долго ждал ответа.

#### 6. Форматы Данных

- **HTML (для людей):** Смесь контента и оформления, сложно парсить программно.
- **JSON (для машин):** Чистые данные, легковесный текстовый формат, легко преобразуется в Python-словарь (dict) или JS-объект.

### II. Эволюция Python в Web: WSGI и ASGI

#### 1. Проблема до WSGI

В конце 90-х — начале 2000-х годов развертывание Python-приложений было "кошмаром" из-за множества несовместимых способов запуска (CGI, mod_python). Фреймворки были привязаны к конкретным серверам, что ограничивало переносимость.

#### 2. WSGI (Web Server Gateway Interface)

WSGI — это универсальный стандарт (протокол PEP 3333), а не программа. Он позволяет любому совместимому серверу (Nginx, Gunicorn) запускать любое совместимое Python-приложение (Django, Flask).

**WSGI Синхронная Модель (Synchronous Model):**

- Модель "поток на запрос" (Thread-per-request).
- Сервер выделяет поток.
- **Блокирующий I/O:** Если поток отправляет запрос к базе данных и ждет (например, 50 мс), он **блокируется**, не позволяя обрабатывать другие запросы, пока не получит ответ.
- **Ограничение:** Масштабирование линейно и ограничено объемом памяти (RAM) из-за необходимости выделения памяти под каждый поток.
- **Интерфейс:** WSGI-приложение — это вызываемый объект (`callable`), принимающий `environ` (словарь с информацией о запросе) и `start_response` (функция обратного вызова для отправки статуса и заголовков).

#### 3. ASGI (Asynchronous Server Gateway Interface)

ASGI — протокол, обеспечивающий **асинхронный** Python для современного веба. Он меняет подход к ожиданию: вместо блокировки потока, асинхронный код **освобождает поток** для выполнения другой работы.

**Архитектура Event Loop:**

- **Кооперативная многозадачность:** Когда Задача А ожидает внешнего I/O (например, ответа от БД), она говорит Event Loop "Разбуди меня, когда ответит БД" (`await`) и освобождает поток.
- Event Loop немедленно берет следующую задачу (Запрос B).
- **Решение C10k Problem:** Один асинхронный процесс может обрабатывать тысячи одновременных соединений.
    - ASGI-задачи (корутины) **чрезвычайно легковесны** (менее 1KB), тогда как каждый WSGI-поток требует больше памяти.
- **Бутылочное горлышко:** ASGI отлично справляется с I/O-операциями (чаты, стриминг, высоконагруженные API), но **тяжелые вычисления (CPU-bound)** блокируют весь Event Loop. Для них нужно использовать отдельные процессы.
- **Интерфейс ASGI:** Асинхронная функция, принимающая `scope` (контекст соединения, содержит `type`), асинхронную функцию `receive` (для получения сообщений) и асинхронную функцию `send` (для отправки сообщений).
- **WebSockets:** Возможность многократно вызывать `receive()` и `send()` в цикле обеспечивает поддержку двустороннего обмена сообщениями, как в мессенджерах.

### III. FastAPI, Pydantic и Типобезопасность

#### 1. Интеграция FastAPI и Pydantic

FastAPI — современный ASGI-фреймворк, использующий **Pydantic** для валидации данных.

**Жизненный Цикл Запроса в FastAPI:**

1. **Receive bytes:** Uvicorn получает HTTP-запрос через ASGI.
2. **Deserialization:** Преобразование JSON в Python-объект.
3. **Validation:** **Pydantic** проверяет, соответствует ли объект заданной схеме.
4. **Dependency Injection:** Внедрение зависимостей (сессия БД, контекст аутентификации).
5. **Execute Logic:** Выполнение бизнес-кода.
6. **Serialize Response:** Pydantic конвертирует Python-объект в JSON.

**Значение Pydantic:** Схема Pydantic — это одновременно и определение данных, и код валидации. Это заменяет десятки ручных проверок (например, что цена > 0 и является float).

#### 2. Проблема N+1 (The N+1 Problem)

Это "тихий убийца производительности".

- **Сценарий:** При получении списка из **N** сущностей (например, 50 Авторов) и попытке доступа к связанным данным (Книгам) через ленивую загрузку (`Lazy Loading`), система выполняет **N + 1 запросов** (1 запрос на авторов + 50 отдельных запросов на книги).
- **Последствия:** Значительная задержка (например, 510 мс вместо 20 мс) из-за сетевой нагрузки.
- **Pydantic V2 Trap:** Высокая скорость Pydantic V2 (на базе Rust) может автоматически запустить N+1, если валидатор касается атрибутов, вызывая ленивую загрузку.

**Решение: Жадная Загрузка (Eager Loading)** Необходимо загрузить связанные данные **заранее**.

- Используются загрузчики SQLAlchemy, такие как **`selectinload`** или `joinedload`.
- **Рекомендация:** `selectinload` предпочтительнее. Он использует второй запрос с условием `WHERE IN` и не создает декартово произведение, что делает его совместимым с пагинацией и асинхронным кодом.

#### 3. Статический Анализ и Type-Driven Development (TDD)

FastAPI активно использует **постепенную типизацию (gradual typing)**.

- **TDD:** Предполагает, что сначала определяются **типы** (контракты входа/выхода), а затем анализатор верифицирует, что реализация им соответствует.
- **Инструменты статического анализа:** **Mypy** (де-факто стандарт, используется с плагинами для Pydantic/SQLAlchemy) и **Pyright** (разработан Microsoft, более строгий, используется в VS Code Pylance).

**Экономика Отказов (Failure Modes):**

- **Динамическая типизация:** **Fail-Late** (отказ поздно). Ошибки обнаруживаются в runtime, часто в продакшене (высокая стоимость).
- **Статический анализ:** **Fail-Early** (отказ рано). Ошибки обнаруживаются на этапе разработки/коммита, обеспечивая "математическое доказательство" корректности (низкая стоимость).

**Безопасный Рефакторинг:** Mypy действует как "компилятор". При изменении структуры модели Mypy немедленно сообщает о каждой затронутой локации в коде, исключая ложные срабатывания и пропущенные ссылки.

**`Optional` Trap:** Типобезопасное решение требует явной обработки `None` с помощью `Optional[T]` для предотвращения ошибок `AttributeError: 'NoneType' has no attribute...`.

### IV. Паттерны и Интеграция DI

#### 1. Внедрение Зависимостей (Dependency Injection - DI)

DI — одна из мощнейших функций FastAPI, полностью управляемая аннотациями типов.

- **Dependency Graph (DAG):** FastAPI строит Граф Зависимостей (Directed Acyclic Graph) при запуске и разрешает зависимости снизу вверх (от базовых к верхнеуровневым).
- **Кэширование:** Зависимости кэшируются **в рамках одного запроса** (`Per-Request Scope`), обеспечивая, например, использование одной и той же сессии/транзакции БД по всей цепочке обработки.

**Управление Ресурсами (`yield`):**

- Для зависимостей, управляющих внешними ресурсами (например, сессия БД), используется `AsyncGenerator`.
- Код, расположенный **после `yield`** в генераторе, гарантированно выполняется как операция очистки (`finally`), даже если в процессе обработки запроса возникло исключение (`except`), обеспечивая возврат соединения в пул.

#### 2. Generic Patterns

**Дженерики** позволяют создавать повторно используемые, типобезопасные компоненты, избегая шаблонного кода.

- **Generic Response Wrapper:** Позволяет определить стандартизированную структуру ответа (например, с полями `data`, `meta`, `status`) один раз, используя плейсхолдеры (`Envelope[User]`, `Envelope[Product]`). FastAPI корректно генерирует OpenAPI-схему для таких обёрток.
- **Generic Pagination Models:** Используются для стандартизации ответа при постраничном выводе (`CustomPage[T]`), разделяя логику пагинации от сущности.

#### 3. Паттерн Generic Repository

Репозиторий — это абстрактный слой базы данных, который обеспечивает слабую связанность и типобезопасность CRUD-операций.

- **Type Constraints:** Репозиторий параметризуется тремя обобщенными типами: `ModelType` (модель ORM), `CreateSchemaType` и `UpdateSchemaType` (модели Pydantic для операций).
- **Операция `update` (PATCH Semantics):** Для корректного частичного обновления (PATCH) необходимо использовать `obj_in.model_dump(**exclude_unset=True**)`. Это гарантирует, что только явно отправленные клиентом поля будут включены в обновление, а остальные существующие поля не будут перезаписаны значением `None`.
- **Clean Endpoint Architecture:** DI позволяет внедрять конкретный репозиторий (`UserRepository`) в конечную точку (`/users`), которая затем делегирует ему бизнес-операции, сохраняя чистую архитектуру и полную типобезопасность.

#### 4. Безопасные Фоновые Задачи (Background Tasks)

**Антипаттерн:** Передача ORM-объектов (SQLAlchemy-моделей) напрямую в фоновые задачи.

- **Причина:** К моменту выполнения задачи сессия БД может быть закрыта, что приведет к ошибке `DetachedInstanceError` при попытке доступа к лениво загруженным атрибутам.
- **Типобезопасный Паттерн:** Передавать в фоновые задачи только **валидированные Pydantic-модели** (`EmailPayload`), которые полностью отвязаны от контекста HTTP-запроса и сессии БД.

### V. Конфигурация Mypy и Ключевые Выводы

Для работы с Pydantic и SQLAlchemy, Mypy требует специальной конфигурации:

- **Plugins:** Обязательное использование плагинов (`pydantic.mypy`, `sqlalchemy.ext.mypy.plugin`), которые позволяют статическому анализатору понимать динамически генерируемые конструкторы моделей.
- **Strictness:** Рекомендуется устанавливать строгие правила (`strict = true`, `disallow_untyped_defs = true`).

**Ключевые Выводы:**

1. **Fail Early (Отказ рано):** Статический анализ переносит обнаружение ошибок из продакшена на этап разработки.
2. **Leverage Generics (Использование дженериков):** Позволяет создавать повторно используемые, типобезопасные компоненты, такие как обертки ответов и репозитории.
3. **Eager Load (Жадная Загрузка):** Использование **`selectinload`** критически важно для предотвращения проблем N+1 и избежания асинхронных ошибок, связанных с ленивой загрузкой.
4. **Configure Mypy (Конфигурация Mypy):** Правильная настройка плагинов раскрывает весь потенциал типобезопасности.

---

Для лучшего понимания того, как ASGI управляет тысячами соединений, представьте себе почтальона, работающего по принципу Event Loop: вместо того, чтобы стоять у дверей первого клиента, пока он медленно читает письмо (блокирующий I/O), почтальон оставляет письмо, переходит к следующему дому, затем к следующему, и только когда ему сообщают, что клиент готов к следующей задаче, он возвращается. Это позволяет одному почтальону эффективно обслуживать весь район, не простаивая в ожидании.