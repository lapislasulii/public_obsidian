
# Конспект: Продвинутая интроспекция и Pydantic

## 1. Введение в интроспекцию: от «Что это?» к «Как это работает?»

Интроспекция в Python делится на два качественных уровня:

- **Пассивная интроспекция:** использование встроенных функций `type()`, `dir()`, `hasattr()` для ответа на вопрос «Что это за объект?».
- **Активная интроспекция:** использование модуля **`inspect`**, который позволяет понять внутреннее устройство объектов и возвращает «живые» объекты вместо простых списков строк.

### Модуль `inspect` и фильтрация членов

Функция `inspect.getmembers()` возвращает список кортежей `(имя, значение)` для всех атрибутов объекта. Чтобы убрать лишний «шум» (например, dunder-методы), используются **предикаты**:

```
import inspect
import os

# Получение только функций из модуля os
functions = inspect.getmembers(os, inspect.isfunction)

# Получение только классов
classes = inspect.getmembers(os, inspect.isclass)
```

Основные предикаты включают `isfunction`, `isclass`, `ismethod`, `isbuiltin` и `ismodule`.

## 2. Работа с исходным кодом и сигнатурами

### Извлечение исходного кода

Функция `inspect.getsource()` позволяет получить исходный код объекта в виде строки, если он определен в файле `.py`. Она не работает для кода, созданного динамически (через `eval()`), встроенных модулей на C или кода, введенного в REPL.

### Сигнатуры функций

`inspect.signature()` — это ключ к современной разработке на Python, позволяющий программно анализировать параметры и типы.

- **`.parameters`:** словарь параметров функции.
- **`.return_annotation`:** подсказка типа возвращаемого значения.
- **`signature.bind()`:** метод, который сопоставляет произвольные `*args` и `**kwargs` с именованными параметрами функции, что позволяет проводить валидацию до вызова.

## 3. Стек вызовов (Call Stack)

Каждый вызов функции помещает **фрейм (frame)** в стек. Модуль `inspect` позволяет заглянуть внутрь этого процесса:

- `inspect.currentframe()`: возвращает текущий фрейм исполнения.
- `inspect.stack()`: возвращает весь стек как список объектов `FrameInfo`.

**Пример «умного» логгера**, который автоматически определяет контекст вызова:

```
import inspect
import logging

def log_info(message: str):
    stack = inspect.stack()
    caller = stack  # Тот, кто вызвал log_info
    filename = caller.filename.split('/')[-1]

    log_msg = f"[{filename}:{caller.lineno} (in {caller.function})] {message}"
    logging.info(log_msg)
    del stack  # Важно для предотвращения циклов ссылок
```

## 4. Метапрограммирование и AST

### Деконструкция магии фреймворков

На примере Flask показано, что декораторы (вроде `@app.route`) — это не «магия», а механизм регистрации. Декоратор выполняется при загрузке модуля, сохраняя объект функции в словаре для последующего вызова при поступлении HTTP-запроса. Для корректной работы интроспекции в декораторах **обязательно** использование `functools.wraps`, иначе теряются метаданные оригинала (`__doc__`, сигнатура).

### AST (Abstract Syntax Trees)

Если `inspect` анализирует объекты в памяти (runtime), то модуль **`ast`** позволяет изменять код до его выполнения.

1. **`ast.parse()`**: превращает текст кода в дерево объектов.
2. **`ast.NodeVisitor`**: используется для анализа дерева (поиск определенных узлов).
3. **`ast.NodeTransformer`**: позволяет заменять узлы, модифицируя логику программы.

**Важный нюанс:** после трансформации дерева необходимо вызвать `ast.fix_missing_locations()`, чтобы «залечить» дерево, добавив в новые узлы информацию о строках, иначе компиляция в байт-код завершится ошибкой.

## 5. Pydantic V2: валидация на основе типов

Pydantic — это практическое применение интроспекции сигнатур. Он автоматизирует проверку данных, используя аннотации типов.

### Базовые возможности

- **Type Coercion (приведение типов):** в стандартном ("Lax") режиме Pydantic пытается конвертировать строки в числа или булевы значения (например, `"123"` в `123`).
- **Strict Mode:** при включении `strict=True` приведение типов отключается.

```
from pydantic import BaseModel, Field

class User(BaseModel):
    id: int
    name: str = Field(min_length=3) # Ограничения через Field
```

### Валидаторы и ValidationInfo

Для сложной бизнес-логики используются `@field_validator`. В Pydantic V2 объект `ValidationInfo` позволяет получить доступ к уже проверенным полям (`info.data`) для кросс-полевой валидации (например, сравнение паролей). **Порядок определения полей критичен**, так как валидация идет сверху вниз.

## 6. Управление конфигурациями (pydantic-settings)

Библиотека `pydantic-settings` решает проблему хаоса в настройках (использование `os.getenv()`), предлагая класс `BaseSettings`.

- **Автозагрузка:** автоматически читает переменные окружения и файлы `.env`.
- **Безопасность:** использование типа `SecretStr` предотвращает утечку паролей в логи.
- **Вложенность:** использование двойного подчеркивания (`DATABASE__HOST`) в `.env` позволяет заполнять вложенные модели настроек.

---

**Аналогия для закрепления:** Если представить ваш код как живой организм, то **`inspect`** — это **рентгеновский аппарат**, позволяющий видеть органы работающего тела. **AST** — это **скальпель хирурга**, позволяющий изменить структуру организма еще до того, как он «оживет». **Pydantic** же выступает в роли **иммунной системы**, которая автоматически проверяет всё, что попадает внутрь, на соответствие заданным типам и правилам.