

Цель лекции — проследить трансформацию класса `Workout` из простого чертежа в сложную, высокопроизводительную абстракцию кода, применяя принципы ООП, метапрограммирования, конкурентности и тестирования.

## 1. Введение в классы и Версия 1: Простой контейнер

В объектно-ориентированном программировании **класс** — это «чертеж» (blueprint), описывающий атрибуты и методы, а **экземпляр** (объект) — это реальное здание, построенное по этому чертежу.

### Версия 1.1: Конструктор и атрибуты

На первом этапе класс просто хранит данные о начале, конце тренировки и калориях.

```
class Workout(object):
    def __init__(self, start, end, calories):
        # Атрибуты экземпляра
        self.start = start
        self.end = end
        self.calories = calories
        self.icon = ""
        self.kind = "workout"
```

**Ключевые моменты:**

- Создание объекта вызывает `__new__` для выделения памяти, а затем `__init__` для инициализации.
- **Модель памяти:** Переменные в Python — это **имена**, ссылающиеся на объекты, а не «коробки» с данными.
- **Передача по ссылке:** При передаче объекта в функцию создается новое имя для того же объекта. Поскольку объекты `Workout` мутабельны, изменения внутри функции видны снаружи.

### Прямой доступ vs Геттеры

Прямое обращение к атрибутам (например, `print(obj.calories)`) считается плохой практикой, так как это жестко связывает код с внутренней реализацией. **Геттеры** (методы доступа) обеспечивают абстракцию: если завтра способ хранения данных изменится, внешний код продолжит работать.

---

## 2. Версия 2: Добавление «интеллекта»

Вторая версия делает класс умнее за счет использования библиотек и вычисляемых свойств.

### Использование инструментов

Вместо хранения дат в виде строк (что делает невозможным расчеты), используются объекты `datetime` и библиотека `dateutil` для парсинга сложных форматов.

```
from dateutil import parser
from datetime import datetime

class Workout:
    def __init__(self, start, end, calories=None):
        self.start: datetime = parser.parse(start)
        self.end: datetime = parser.parse(end)
        self.calories = calories
```

### Переменные класса и @property

- **Переменные класса** (например, `CALS_PER_HOUR`) разделяются всеми экземплярами.
- Декоратор **`@property`** превращает метод в атрибут только для чтения, делая интерфейс «питоничным» и скрывая логику вычислений.

```
@property
def duration(self):
    return self.end - self.start

@property
def calories_burned(self):
    if self.calories is not None:
        return self.calories
    # Автоматический расчет, если калории не указаны
    hours = self.duration.total_seconds() / 3600
    return hours * self.CALS_PER_HOUR
```

---

## 3. Версия 3: Идиоматичный Python (Dunder-методы)

Магические (dunder) методы позволяют объектам интегрироваться в протоколы языка Python.

- **`__repr__` vs `__str__`**: `__repr__` предназначен для разработчиков (однозначность), а `__str__` — для конечных пользователей (читаемость).
- **Перегрузка операторов**: Реализация `__len__` позволяет использовать `len(workout)`, а `__add__` — складывать две тренировки с помощью оператора `+`.
- **Эмуляция контейнера**: Метод `__getitem__` позволяет обращаться к списку упражнений внутри тренировки по индексу: `workout`.

---

## 4. Версия 4: Архитектура и расширяемость

### Наследование и полиморфизм

Для разных видов активности (бег, велоспорт) создаются подклассы. Они наследуют общую логику, но могут иметь свои константы (например, разный расход калорий в час). **Полиморфизм** позволяет обрабатывать разные типы тренировок единообразно через общий интерфейс.

### Фабричные и утилитарные методы

- **`@classmethod`**: Используется как альтернативный конструктор (например, для создания объекта из словаря/JSON).
- **`@staticmethod`**: Вспомогательная функция, логически связанная с классом, но не требующая доступа к его состоянию.

### Метаклассы

Метаклассы позволяют контролировать процесс создания классов. В примере используется `WorkoutMeta` для **автоматической регистрации** всех новых подклассов в реестре `WORKOUT_REGISTRY`. Это критически важно для создания расширяемых фреймворков.

---

## 5. Версия 5: Оптимизация производительности

При обработке больших данных или запросах к API важно выбрать правильный инструмент конкурентности.

|Тип задачи|Подходящий инструмент|Особенности|
|:--|:--|:--|
|**I/O-Bound** (сеть, диск)|`threading`, `asyncio`|Ожидание ответа. `asyncio` эффективнее для тысяч операций.|
|**CPU-Bound** (вычисления)|`multiprocessing`|Обход **GIL** (Global Interpreter Lock). Использование всех ядер процессора.|

- **GIL** — это мьютекс в CPython, который позволяет выполнять только один поток байт-кода одновременно, что делает многопоточность бесполезной для вычислений.
- Для обмена данными между процессами (у которых изолированная память) используется `multiprocessing.Queue`.

---

## 6. Версия 6: Профессиональный подход

Профессиональный проект отличается четкой структурой и использованием современных инструментов управления.

- **Структура проекта**: Использование `src-layout` для предотвращения случайных импортов и надежного тестирования.
- **`pyproject.toml`**: Единый источник истины для конфигурации проекта, зависимостей и скриптов (заменяет `setup.py` и `requirements.txt`).
- **Статическая типизация**: Использование аннотаций типов и инструмента `mypy` для повышения надежности кода.

---

**Аналогия для закрепления:** Разработка класса похожа на **строительство дома**. Сначала вы рисуете схему комнат (Версия 1), затем проводите электричество и автоматизацию (Версия 2), делаете интерьер удобным для жильцов (Версия 3), предусматриваете возможность пристройки новых этажей (Версия 4), оптимизируете лифты для быстрой работы (Версия 5) и, наконец, оформляете все официальные документы и чертежи по ГОСТу (Версия 6).