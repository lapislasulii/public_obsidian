Ниже представлен подробный конспект лекции и презентации, посвященный методам обеспечения надежности и гибкости кода в Python через аннотации типов, контроль зависимостей и интроспекцию.

---

# Конспект: Типизация, контроль зависимостей и интроспекция в Python

Основная философия лекции заключается в сознательном ограничении динамической природы Python ради **стабильности** и **корректности** программного продукта. Если пользователь может совершить глупость в коде, он обязательно это сделает, поэтому задача разработчика — подготовиться к этому.

## 1. Аннотации типов: Делаем динамическое статическим

Python — динамически типизированный язык, где типы проверяются интерпретатором во время выполнения (Runtime). Однако для крупных проектов это несет риски появления ошибок в продакшене (например, `TypeError` при сложении строки и числа).

### Три столпа надежного кода:

1. **Корректность:** Использование аннотаций типов и статического анализатора Mypy для поиска ошибок до запуска кода.
2. **Стабильность:** Контроль зависимостей, чтобы избежать «ада зависимостей» (dependency hell).
3. **Гибкость:** Интроспекция — способность кода анализировать и модифицировать себя во время работы.

### Постепенная типизация (Gradual Typing)

Python использует гибридный путь: интерпретатор полностью игнорирует аннотации типов во время выполнения, но они служат подсказками (hints) для инструментов статического анализа и IDE.

```
# Пример: Интерпретатор проигнорирует ошибку, но Mypy ее подсветит
my_var: int = "hello"
print(my_var)  # Выведет 'hello' без ошибки в рантайме
```

### Преимущества аннотаций:

- **Статический анализ:** Поиск багов с помощью Mypy.
- **Поддержка IDE:** Работа автодополнения и подсветка ошибок.
- **Живая документация:** Типы лучше любых комментариев объясняют, что функция ждет на вход и что отдает на выход.

### Базовый синтаксис (PEP 484 и PEP 526)

Аннотации можно применять к функциям, переменным и классам.

```
# Аннотация функций
def add(left: int, right: int) -> int:
    return left + right

# Аннотация переменных
primes: list[int] =
captain: str  # Декларация без инициализации

# Аннотация классов
from typing import ClassVar
class Starship:
    stats: ClassVar[dict] = {}  # Переменная класса
```

### Современный синтаксис (Python 3.9+ и 3.10+)

В новых версиях Python отпала необходимость импортировать базовые коллекции из модуля `typing`, а для объединения типов используется оператор `|`.

```
# Старый стиль (до 3.8)
from typing import List, Union, Optional
items: List[int] =
item_id: Union[int, str] = 123
user: Optional[str] = None

# Современный стиль (3.10+)
items: list[int] =
item_id: int | str = "abc"
user: str | None = None
```

### Продвинутая типизация: Generics и Protocol

- **TypeVar:** Создает связь между типами входных и выходных данных.
- **Generic:** Позволяет создавать кастомные объекты (например, стек), работающие с любым типом данных, сохраняя при этом проверку типов.
- **Protocol (PEP 544):** Статическая «утиная типизация». Позволяет описывать ожидаемую структуру (методы/атрибуты) объекта без привязки к иерархии наследования.

```
from typing import Protocol

class CanMakeSound(Protocol):
    def make_sound(self) -> None: ...

class Dog:  # Не наследуется от CanMakeSound явно
    def make_sound(self) -> None:
        print("Woof!")

def trigger_sound(obj: CanMakeSound):
    obj.make_sound()

trigger_sound(Dog())  # OK: структура совпадает
```

---

## 2. Mypy: Практический статический анализ

**Mypy** — это де-факто стандартный инструмент (линтер), который проверяет типы в коде без его запуска.

### Особенности работы с Mypy:

1. **По умолчанию Mypy почти бесполезен**, так как считает неаннотированные функции типом `Any` и пропускает ошибки.
2. **Конфигурация (mypy.ini):** Для профессиональной разработки критически важно включить строгие флаги.
    - `disallow_untyped_defs = True` — запрещает функции без аннотаций.
    - `strict_optional = True` — заставляет обрабатывать `None`.
3. **Type Narrowing:** Чтобы Mypy не ругался на возможные ошибки (например, когда переменная может быть `str | None`), нужно «сузить» тип с помощью проверки `isinstance()`.

```
def process_data(data: str | int) -> str:
    if isinstance(data, int):
        return f"Number: {data}"
    return data.upper()  # Mypy знает, что здесь data — это str
```

---

## 3. Контроль зависимостей

Проблема **Dependency Hell** возникает, когда разные пакеты требуют несовместимые версии одной и той же зависимости.

### Эволюция инструментов:

- **Традиционный подход (venv + requirements.txt):** Имеет критические недостатки: смешивает прямые и транзитивные зависимости, не разделяет окружения для разработки и продакшена, сборки не детерминированы.
- **Pipenv:** Вводит файлы `Pipfile` (человекочитаемый) и `Pipfile.lock` (детерминированный, с хэшами).
- **Poetry:** Современный стандарт. Использует `pyproject.toml`, обладает лучшим алгоритмом разрешения зависимостей (resolver) и управляет полным жизненным циклом проекта.

---

## 4. Интроспекция: Код как данные

**Интроспекция** — это способность программы изучать собственную структуру (типы, атрибуты, методы) во время выполнения.

### Инструменты интроспекции:

- `type()` против `isinstance()`: всегда лучше использовать `isinstance()`, так как она учитывает иерархию наследования.
- `dir()`: список всех атрибутов и методов.
- `hasattr()` / `getattr()`: проверка и получение атрибута по строковому имени (ключ к метапрограммированию).
- `callable()`: проверка, можно ли вызвать объект как функцию.

### Модуль `inspect`: «Тяжелая артиллерия»

Позволяет получать исходный код функций (`getsource`), читать документацию (`getdoc`) и анализировать сигнатуры.

**`inspect.signature()`** — самый важный инструмент. Он позволяет современным фреймворкам (как FastAPI) «видеть», какие аргументы и типы ожидает ваша функция, и автоматически валидировать входящие данные.

```
import inspect

def my_func(a: int, b: str = 'default') -> bool:
    pass

sig = inspect.signature(my_func)
for name, param in sig.parameters.items():
    print(f"Аргумент: {name}, Тип: {param.annotation}, Дефолт: {param.default}")
```

### Итог

Сочетание аннотаций типов, строгого Mypy, современной системы управления зависимостями (Poetry) и интроспекции позволяет создавать код, который одновременно является и **надежным**, и **гибким**.

> **Метафора:** Аннотации типов и Mypy — это как чертеж здания: они позволяют найти ошибки в конструкции еще до того, как будет заложен первый кирпич. Интроспекция же — это датчики внутри здания, которые позволяют ему понимать свое состояние и адаптироваться к изменениям в реальном времени.