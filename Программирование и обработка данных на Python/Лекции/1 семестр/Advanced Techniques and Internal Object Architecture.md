
### Часть I: Анатомия объекта

В основе Python лежит концепция, согласно которой всё является объектом. Каждый объект определяется фундаментальной триадой характеристик:

1. **Identity (Идентичность):** Уникальный адрес объекта в памяти, получаемый через `id()`. Она неизменна в течение всей жизни объекта.
2. **Type (Тип):** «Чертеж» объекта, определяющий его структуру и доступные операции. Проверяется через `type()`.
3. **Value (Значение):** Фактические данные. Могут быть изменяемыми (mutable, как `list`) или неизменяемыми (immutable, как `tuple`).

#### Жизненный цикл объекта

Вопреки распространенному мнению, `__init__` не является конструктором. Настоящий конструктор — это **`__new__`**.

- **`__new__`**: Статический метод, который вызывается первым, выделяет память и возвращает новый экземпляр класса.
- **`__init__`**: Инициализатор, который настраивает состояние уже созданного объекта.
- **`__del__`**: Финализатор, вызываемый, когда счетчик ссылок достигает нуля. Его вызов не детерминирован, поэтому для очистки ресурсов (файлов, сокетов) следует использовать контекстные менеджеры.

**Пример реализации конструктора и инициализатора:**

```
class Point:
    def __new__(cls, x, y):
        print("Point.__new__ called to create instance")
        return super().__new__(cls)

    def __init__(self, x, y):
        print(f"Point.__init__ called with ({x}, {y})")
        self.x = x
        self.y = y

p = Point(10, 20)
```

#### Представление объекта

Для отображения объектов используются два метода:

- **`__repr__`**: Для разработчиков (техническое, однозначное, в идеале воспроизводимое через `eval()`).
- **`__str__`**: Для пользователей (читаемое, дружелюбное).

---

### Часть II: Доступ к атрибутам и дескрипторы

#### Хранение атрибутов: `__dict__` vs `__slots__`

- **`__dict__`**: По умолчанию атрибуты хранятся в словаре. Это обеспечивает динамичность (можно добавлять атрибуты на лету), но потребляет много памяти.
- **`__slots__`**: Оптимизация, заменяющая словарь фиксированным массивом. Это значительно экономит память и ускоряет доступ, но запрещает создание новых атрибутов, не указанных в слотах.

#### Протокол дескрипторов

Дескрипторы — это объекты классов, реализующие методы `__get__`, `__set__` или `__delete__`. Они лежат в основе работы свойств (`@property`) и методов.

- **Data Descriptors**: Реализуют `__set__` или `__delete__`. Имеют приоритет над словарем экземпляра.
- **Non-Data Descriptors**: Реализуют только `__get__` (например, обычные методы). Словарь экземпляра может их перекрывать.

**Пример дескриптора для валидации:**

```
class PositiveNumber:
    def __set_name__(self, owner, name):
        self.private_name = '_' + name

    def __get__(self, instance, owner):
        return getattr(instance, self.private_name)

    def __set__(self, instance, value):
        if value <= 0:
            raise ValueError("Value must be positive")
        setattr(instance, self.private_name, value)

class Product:
    price = PositiveNumber()
    def __init__(self, price):
        self.price = price
```

---

### Часть III: Протоколы поведения

Python использует **dunder-методы** (двойное подчеркивание) как «крючки» для интеграции объектов в синтаксис языка.

#### Итерация и генераторы

Для поддержки цикла `for` объект должен реализовать метод `__iter__`, возвращающий итератор, а итератор — метод `__next__`. **Генераторы** (функции с `yield`) упрощают создание итераторов, управляют состоянием автоматически и экономят память за счет ленивых вычислений.

#### Контекстные менеджеры (`with`)

Используются для гарантированного освобождения ресурсов через методы `__enter__` и `__exit__`. Декоратор `@contextmanager` позволяет создавать их на базе генераторов.

**Пример таймера через `@contextmanager`:**

```
from contextlib import contextmanager
import time

@contextmanager
def timer_context():
    start = time.perf_counter()
    try:
        yield
    finally:
        end = time.perf_counter()
        print(f"Executed in {end - start:.4f}s")
```

---

### Часть IV: Иерархия классов и MRO

При множественном наследовании возникает **«проблема ромба»** (diamond problem) — неопределенность того, какой метод родителя вызывать. Python решает это с помощью алгоритма **C3-линеаризации**, который вычисляет **MRO (Method Resolution Order)**.

**Правила MRO:**

1. Дочерние классы проверяются перед родительскими.
2. Порядок перечисления родителей сохраняется.
3. Монотонность: MRO подкласса не противоречит MRO родителей.

---

### Практический пример: LogFileParser

Презентация завершается примером класса, объединяющего все изученные протоколы.

```
class LogFileParser:
    def __init__(self, filepath):
        self.filepath = filepath
        self._file = None

    # Контекстный менеджер
    def __enter__(self):
        self._file = open(self.filepath, 'r')
        return self

    def __exit__(self, *args):
        if self._file: self._file.close()

    # Протокол итерации (генератор)
    def __iter__(self):
        for line in self._file:
            yield line.strip() # Ленивое чтение
```

**Ключевой вывод:** Философия Python заключается в том, что «всё есть объект, и всё работает через протоколы». Понимание dunder-методов позволяет создавать объекты, которые бесшовно интегрируются в экосистему языка.