
### 1. Конвертер систем счисления

Функция для перевода числа из любой системы счисления (от 2 до 36) в десятичную.

```python
def convert_to_decimal(number_str, base):
    """
    Переводит число из заданной системы счисления в десятичную.

    Аргументы:
    number_str (str): Строковое представление числа.
    base (int): Основание исходной системы счисления (от 2 до 36).

    Возвращает:
    int: Десятичное представление числа.
    ValueError: Если основание некорректно или число содержит недопустимые символы.
    """
    if not (2 <= base <= 36):
        raise ValueError("Основание системы счисления должно быть от 2 до 36.")

    decimal_value = 0
    power = 0
    # Перебираем символы числа справа налево
    for digit_char in reversed(number_str.upper()):
        # Определяем числовое значение символа
        if '0' <= digit_char <= '9':
            digit_value = int(digit_char)
        elif 'A' <= digit_char <= 'Z':
            digit_value = ord(digit_char) - ord('A') + 10
        else:
            raise ValueError(f"Недопустимый символ '{digit_char}' для системы счисления с основанием {base}.")

        # Проверяем, что значение цифры не превышает основание
        if digit_value >= base:
            raise ValueError(f"Символ '{digit_char}' недопустим для системы счисления с основанием {base}.")

        # Добавляем к десятичному значению
        decimal_value += digit_value * (base ** power)
        power += 1
    return decimal_value

# Пример использования:
# print(convert_to_decimal("101", 2))    # 5
# print(convert_to_decimal("A", 16))     # 10
# print(convert_to_decimal("1A", 16))    # 26
# print(convert_to_decimal("Z", 36))     # 35
```

### 2. Польский калькулятор (Обратная польская нотация)

Реализация вычисления выражения, записанного в обратной польской нотации (ОПН), используя стек.

```python
def rpn_calculator(expression):
    """
    Вычисляет выражение, записанное в обратной польской нотации (ОПН).

    Аргументы:
    expression (str): Строка с выражением ОПН, элементы разделены пробелами.
                      Поддерживает операции +, -, *, /.

    Возвращает:
    float: Результат вычисления выражения.
    ValueError: Если выражение некорректно.
    """
    stack = []
    operators = {'+', '-', '*', '/'}

    # Разделяем выражение на токены (числа и операторы)
    tokens = expression.split()

    for token in tokens:
        if token not in operators:
            # Если токен - число, преобразуем его в float и помещаем в стек
            try:
                stack.append(float(token))
            except ValueError:
                raise ValueError(f"Некорректный токен в выражении: {token}")
        else:
            # Если токен - оператор, извлекаем два операнда из стека
            if len(stack) < 2:
                raise ValueError("Недостаточно операндов для операции.")
            operand2 = stack.pop()
            operand1 = stack.pop()

            # Выполняем операцию и помещаем результат обратно в стек
            if token == '+':
                stack.append(operand1 + operand2)
            elif token == '-':
                stack.append(operand1 - operand2)
            elif token == '*':
                stack.append(operand1 * operand2)
            elif token == '/':
                if operand2 == 0:
                    raise ValueError("Деление на ноль.")
                stack.append(operand1 / operand2)

    # В конце в стеке должен остаться только один элемент - результат
    if len(stack) != 1:
        raise ValueError("Некорректное выражение ОПН.")

    return stack[0]

# Пример использования:
# print(rpn_calculator("3 4 +"))         # 7.0
# print(rpn_calculator("3 4 + 2 *"))      # 14.0 ( (3 + 4) * 2 )
# print(rpn_calculator("5 1 2 + 4 * + 3 -")) # 14.0 ( 5 + (1 + 2) * 4 - 3 )
```

### 3. Перевод целого числа от 0 до 999 в текстовое представление на русском

```python
def number_to_text_russian(number):
    """
    Переводит целое число от 0 до 999 в текстовое представление на русском языке.
    """
    if not (0 <= number <= 999):
        raise ValueError("Число должно быть в диапазоне от 0 до 999.")

    if number == 0:
        return "ноль"

    units = ["", "один", "два", "три", "четыре", "пять", "шесть", "семь", "восемь", "девять"]
    teens = ["", "одиннадцать", "двенадцать", "тринадцать", "четырнадцать", "пятнадцать",
             "шестнадцать", "семнадцать", "восемнадцать", "девятнадцать"]
    tens = ["", "десять", "двадцать", "тридцать", "сорок", "пятьдесят",
            "шестьдесят", "семьдесят", "восемьдесят", "девяносто"]
    hundreds = ["", "сто", "двести", "триста", "четыреста", "пятьсот",
                "шестьсот", "семьсот", "восемьсот", "девятьсот"]

    result = []

    # Сотни
    h = number // 100
    if h > 0:
        result.append(hundreds[h])
    
    remaining = number % 100

    # Десятки и единицы
    if remaining > 0:
        if 10 <= remaining <= 19:
            result.append(teens[remaining - 10 + 1]) # +1 потому что teens[0] пустой
        else:
            t = remaining // 10
            u = remaining % 10
            if t > 0:
                result.append(tens[t])
            if u > 0:
                result.append(units[u])

    return " ".join(result).strip()

# Пример использования:
# print(number_to_text_russian(0))    # ноль
# print(number_to_text_russian(7))    # семь
# print(number_to_text_russian(15))   # пятнадцать
# print(number_to_text_russian(42))   # сорок два
# print(number_to_text_russian(100))  # сто
# print(number_to_text_russian(256))  # двести пятьдесят шесть
# print(number_to_text_russian(999))  # девятьсот девяносто девять
```

### 4. Класс итераторов для геометрической прогрессии

```python
class GeometricProgression:
    """
    Класс-итератор, генерирующий геометрическую прогрессию.
    """
    def __init__(self, start, ratio, count=None):
        """
        Инициализирует геометрическую прогрессию.

        Аргументы:
        start (int/float): Первый член прогрессии.
        ratio (int/float): Знаменатель прогрессии.
        count (int, optional): Количество членов прогрессии для генерации.
                               Если None, генерирует бесконечную прогрессию.
        """
        self.start = start
        self.ratio = ratio
        self.count = count
        self.current_value = start
        self.current_index = 0

    def __iter__(self):
        """Возвращает сам объект как итератор."""
        self.current_value = self.start  # Сброс состояния для нового итерирования
        self.current_index = 0
        return self

    def __next__(self):
        """
        Возвращает следующий член геометрической прогрессии.
        """
        if self.count is not None and self.current_index >= self.count:
            raise StopIteration

        value_to_return = self.current_value
        self.current_value *= self.ratio
        self.current_index += 1
        return value_to_return

# Пример использования:
# # Прогрессия из 5 членов: 2, 6, 18, 54, 162
# gp1 = GeometricProgression(start=2, ratio=3, count=5)
# print("Прогрессия из 5 членов:")
# for num in gp1:
#     print(num)

# # Бесконечная прогрессия (нужно ограничить вручную)
# gp2 = GeometricProgression(start=1, ratio=0.5)
# print("\nБесконечная прогрессия (первые 7 членов):")
# for i, num in enumerate(gp2):
#     if i >= 7:
#         break
#     print(num)
```

### 5. Реализация простейшего односвязного списка

```python
class Node:
    """
    Представляет узел односвязного списка.
    """
    def __init__(self, data):
        self.data = data
        self.next = None  # Ссылка на следующий узел

class SinglyLinkedList:
    """
    Простейший односвязный список.
    """
    def __init__(self):
        self.head = None  # Голова списка (первый узел)

    def append(self, data):
        """
        Добавляет новый узел в конец списка.
        """
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            return
        
        last_node = self.head
        while last_node.next:
            last_node = last_node.next
        last_node.next = new_node

    def prepend(self, data):
        """
        Добавляет новый узел в начало списка.
        """
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

    def delete_node(self, key):
        """
        Удаляет первый узел, содержащий заданное значение (key).
        """
        current_node = self.head

        # Если удаляемый узел - голова списка
        if current_node and current_node.data == key:
            self.head = current_node.next
            current_node = None
            return

        prev_node = None
        while current_node and current_node.data != key:
            prev_node = current_node
            current_node = current_node.next

        # Если узел не найден
        if current_node is None:
            return

        # Удаляем узел, перенаправляя ссылку предыдущего
        prev_node.next = current_node.next
        current_node = None

    def print_list(self):
        """
        Выводит все элементы списка.
        """
        current_node = self.head
        elements = []
        while current_node:
            elements.append(str(current_node.data))
            current_node = current_node.next
        print(" -> ".join(elements))

# Пример использования:
# my_list = SinglyLinkedList()
# my_list.append(1)
# my_list.append(2)
# my_list.append(3)
# my_list.print_list() # Вывод: 1 -> 2 -> 3

# my_list.prepend(0)
# my_list.print_list() # Вывод: 0 -> 1 -> 2 -> 3

# my_list.delete_node(2)
# my_list.print_list() # Вывод: 0 -> 1 -> 3

# my_list.delete_node(0)
# my_list.print_list() # Вывод: 1 -> 3

# my_list.delete_node(5) # Попытка удалить несуществующий элемент
# my_list.print_list() # Вывод: 1 -> 3
```

### 6. Функция проверки строки на палиндром

```python
def is_palindrome_slice(s):
    """
    Проверяет, является ли строка палиндромом, используя срезы.
    Игнорирует регистр и неалфавитные символы.
    """
    # Приводим к нижнему регистру и оставляем только буквы и цифры
    cleaned_s = "".join(char.lower() for char in s if char.isalnum())
    return cleaned_s == cleaned_s[::-1] # Сравниваем строку с её перевёрнутой версией

def is_palindrome_no_slice(s):
    """
    Проверяет, является ли строка палиндромом, без использования срезов.
    Использует два указателя. Игнорирует регистр и неалфавитные символы.
    """
    cleaned_s = "".join(char.lower() for char in s if char.isalnum())
    
    left = 0
    right = len(cleaned_s) - 1

    while left < right:
        if cleaned_s[left] != cleaned_s[right]:
            return False
        left += 1
        right -= 1
    return True

# Пример использования:
# print("Через срезы:")
# print(is_palindrome_slice("madam"))          # True
# print(is_palindrome_slice("A man, a plan, a canal: Panama")) # True
# print(is_palindrome_slice("hello"))          # False
# print(is_palindrome_slice("Racecar"))        # True

# print("\nБез срезов:")
# print(is_palindrome_no_slice("madam"))          # True
# print(is_palindrome_no_slice("A man, a plan, a canal: Panama")) # True
# print(is_palindrome_no_slice("hello"))          # False
# print(is_palindrome_no_slice("Racecar"))        # True
```

### 7. Кэширование: Реализация простейшего декоратора `@lru_cache`

Простейший декоратор для мемоизации функции вычисления чисел Фибоначчи с использованием словаря. Это не полноценный LRU (Least Recently Used) кэш, а скорее простой мемоизатор.

```python
def simple_cache(func):
    """
    Простейший декоратор для кэширования результатов функции.
    Кэш хранится в словаре.
    """
    cache = {} # Словарь для хранения кэшированных результатов

    def wrapper(*args, **kwargs):
        # Создаем ключ для кэша из аргументов функции
        # Важно, чтобы аргументы были хешируемыми (например, кортежи)
        key = (args, frozenset(kwargs.items())) 
        
        if key in cache:
            # Если результат есть в кэше, возвращаем его
            # print(f"Возвращаем из кэша для {args}") # Для отладки
            return cache[key]
        else:
            # Иначе вычисляем результат, сохраняем в кэш и возвращаем
            # print(f"Вычисляем для {args}") # Для отладки
            result = func(*args, **kwargs)
            cache[key] = result
            return result
    return wrapper

@simple_cache
def fibonacci(n):
    """
    Вычисляет n-е число Фибоначчи рекурсивно.
    """
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

# Пример использования:
# print(fibonacci(10)) # Вычислит fib(10), fib(9), fib(8) и т.д., но каждый раз только один раз
# print(fibonacci(5))  # Эти вызовы будут использовать кэшированные значения
# print(fibonacci(10)) # Этот вызов полностью возьмёт результат из кэша
```

### 8. Функция на определение "счастливого" числа

```python
def is_happy_number(n):
    """
    Определяет, является ли число "счастливым".
    "Счастливое" число - это число, для которого сумма квадратов его цифр
    в цикле сходится к 1. Если цикл заходит в бесконечную петлю, не содержащую 1,
    число не является счастливым.
    """
    seen_numbers = set() # Множество для отслеживания уже встреченных чисел в цикле

    def get_next_number(num):
        """Вспомогательная функция: вычисляет сумму квадратов цифр числа."""
        sum_sq = 0
        while num > 0:
            digit = num % 10
            sum_sq += digit * digit
            num //= 10
        return sum_sq

    current_num = n
    while current_num != 1 and current_num not in seen_numbers:
        seen_numbers.add(current_num)
        current_num = get_next_number(current_num)
    
    return current_num == 1

# Пример использования:
# print(is_happy_number(19))  # True
# # 1^2 + 9^2 = 1 + 81 = 82
# # 8^2 + 2^2 = 64 + 4 = 68
# # 6^2 + 8^2 = 36 + 64 = 100
# # 1^2 + 0^2 + 0^2 = 1

# print(is_happy_number(7))   # True
# # 7^2 = 49
# # 4^2 + 9^2 = 16 + 81 = 97
# # 9^2 + 7^2 = 81 + 49 = 130
# # 1^2 + 3^2 + 0^2 = 1 + 9 + 0 = 10
# # 1^2 + 0^2 = 1

# print(is_happy_number(4))   # False (цикл 4 -> 16 -> 37 -> 58 -> 89 -> 145 -> 42 -> 20 -> 4)
```

### 9. Функция проверки скобочной последовательности

```python
def is_valid_bracket_sequence(s):
    """
    Проверяет корректность скобочной последовательности из '(', '[', '{'.
    """
    stack = []
    bracket_map = {')': '(', ']': '[', '}': '{'} # Карта закрывающих скобок к открывающим

    for char in s:
        if char in bracket_map.values():
            # Если это открывающая скобка, помещаем её в стек
            stack.append(char)
        elif char in bracket_map.keys():
            # Если это закрывающая скобка
            if not stack or stack.pop() != bracket_map[char]:
                # Если стек пуст или верхний элемент стека не соответствует
                # ожидаемой открывающей скобке, последовательность некорректна
                return False
        # Игнорируем любые другие символы, не являющиеся скобками

    # Если стек пуст, значит все скобки были корректно закрыты
    return not stack

# Пример использования:
# print(is_valid_bracket_sequence("()[]{}"))    # True
# print(is_valid_bracket_sequence("([{}])"))    # True
# print(is_valid_bracket_sequence("{[()]}"))    # True
# print(is_valid_bracket_sequence("({[})"))     # False (неправильный порядок)
# print(is_valid_bracket_sequence("((("))       # False (незакрытые скобки)
# print(is_valid_bracket_sequence("(()"))       # False
# print(is_valid_bracket_sequence("]"))         # False (закрывающая без открывающей)
# print(is_valid_bracket_sequence(""))          # True (пустая строка корректна)
```

### 10. Функция бинпоиска (бинарного поиска)

```python
def binary_search(arr, target):
    """
    Реализует бинарный поиск элемента в отсортированном списке.

    Аргументы:
    arr (list): Отсортированный список чисел.
    target (int/float): Искомый элемент.

    Возвращает:
    int: Индекс элемента, если он найден.
    -1: Если элемент не найден.
    """
    left = 0
    right = len(arr) - 1

    while left <= right:
        mid = (left + right) // 2 # Вычисляем средний индекс

        if arr[mid] == target:
            return mid # Элемент найден
        elif arr[mid] < target:
            left = mid + 1 # Искомый элемент находится в правой половине
        else:
            right = mid - 1 # Искомый элемент находится в левой половине
    
    return -1 # Элемент не найден

# Пример использования:
# sorted_list = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]

# print(binary_search(sorted_list, 12))  # 3 (индекс 12)
# print(binary_search(sorted_list, 56))  # 7 (индекс 56)
# print(binary_search(sorted_list, 2))   # 0 (индекс 2)
# print(binary_search(sorted_list, 91))  # 9 (индекс 91)
# print(binary_search(sorted_list, 30))  # -1 (30 нет в списке)
# print(binary_search(sorted_list, 1))   # -1
# print(binary_search(sorted_list, 100)) # -1
```