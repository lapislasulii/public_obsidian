
## 1. Алгоритм Форда-Беллмана (Ford-Bellman)

Алгоритм Форда-Беллмана позволяет находить кратчайшие маршруты от **одной вершины до всех остальных**.

**Основная идея**

Алгоритм строится на предположении, что мы можем посчитать кратчайшие маршруты. Идея состоит в том, что сначала мы находим кратчайшие маршруты длиной **не более чем $k$ ребер**, а затем, используя эти данные, находим результат для маршрутов длиной **не более чем $k+1$ ребро**.

Дистанция $D_k(A, B)$ обозначает кратчайшую стоимость пути от $A$ до $B$, содержащего **не более чем $k$ ребер**.

Для перехода от $k$ к $k+1$ ребру, если путь в вершину $B$ проходит через соседа $C$ (или $D$), то длина маршрута будет равна минимуму из всех возможных вариантов: $$D_{k+1}(A, B) = \min(D_k(A, B), \min_{v \in \text{Neighbors}(B)} { D_k(A, v) + \text{weight}(v, B) })$$ Формально это было записано как $D_{k+1}(A, B) = \min(D_k(A, C) + x, D_k(A, D) + y)$.

**Релаксация**

По сути, алгоритм перебирает все возможные ребра и пытается оптимизировать массив кратчайших расстояний. Процесс обновления кратчайших расстояний путем перебора серверов называется **релаксацией расстояния** (релаксация расстояния).

**Реализация и Гарантии**

1. **Инициализация:** Массив расстояний (dv) инициализируется бесконечностью ($\infty$), а стартовая вершина — нулем (0).
2. **Итерации:** Алгоритм должен повторить основной цикл **фиксированное количество раз**.
    - Кратчайший маршрут в графе обязан быть **простой цепью**.
    - Максимальная длина простой цепи в графе с $N$ вершинами равна **$N-1$** (например, Гамильтонов путь).
    - На $i$-й итерации цикла значение ячейки $D_v$ содержит минимальное расстояние среди всех маршрутов длиной **не более чем $i$ ребер**.
3. **Оптимизация:** Если за итерацию ни одно расстояние не изменилось (массив $D$ не поменялся), это означает, что достигнут оптимум, и алгоритм можно остановить.

**Отрицательные циклы**

- Алгоритм Форда-Беллмана **работает с отрицательными весами** ребер.
- Он может **обнаруживать отрицательные циклы**.
- **Обнаружение:** Если на последней итерации цикла (которая равна количеству вершин $N$) происходит изменение расстояний, это означает, что в графе **есть отрицательный цикл**.
- Если отрицательный цикл существует, **не всегда есть кратчайший маршрут конечной длины**, так как по циклу можно наворачивать круги и получать сколь угодно малое число.

**Асимптотика**

В худшем случае скорость работы алгоритма оценивается как **$O(V \cdot E)$** (количество вершин, умноженное на количество ребер).

**Применимость:** Выгодно использовать, когда граф **разрежен** (то есть имеет относительно мало ребер по сравнению с $V^2$). Если граф неразрежен, его использовать не стоит (за редким исключением).

---

## 2. Алгоритм Дейкстры (Dijkstra)

Алгоритм Дейкстры также находит кратчайшие расстояния **от одной вершины до всех остальных**.

**Основная идея**

Идея алгоритма основана на **Breadth-First Search (BFS)**. BFS гарантирует выбор ближайшей вершины по приоритетам.

**Реализация**

В отличие от стандартного BFS, который использует обычную очередь (FIFO), Дейкстра использует "волшебную" очередь (контейнер).

1. **Контейнер:** Вместо функции `pop` используется функция **`popMin`**, которая возвращает вершину, до которой **текущее расстояние минимально**.
2. **Структура данных:** Контейнером в идеале является структура, позволяющая быстро добавлять и удалять элементы, например, дерево (минимальная куча/min-heap).
3. **Правило посещения:** Если вершина была **изъята из контейнера**, ее расстояние считается окончательным, и оно **никогда больше не пересчитывается**.

**Ограничения**

- Алгоритм Дейкстры **не применим** (не работает) для графов, содержащих **отрицательные ребра**, даже если в них нет отрицательных циклов.
- Алгоритм **не может обнаруживать отрицательные циклы**.

**Асимптотика**

Асимптотика, при условии эффективной реализации `popMin` и `push` (за $O(\log V)$), составляет **$O(E + V \log V)$**. В разреженных графах он может быть быстрее, чем Форд-Беллман, но в неразреженных графах (без оптимизированных структур) может достигать $O(E + V^2)$, что все еще быстрее, чем Форд-Беллман в неразреженных графах.

---

## 3. Алгоритм Флойда-Уоршелла (Floyd-Warshall)

Алгоритм Флойда-Уоршелла — это "гигачад" (по сравнению с другими). Он находит кратчайшие пути **из каждой вершины в каждую** (все пары кратчайших путей).

**Общие свойства**

- Работает с **отрицательными ребрами**.
- **Обнаруживает отрицательные циклы**.
- В худшем случае работает за то же время, что и Форд-Беллман (подразумевается, что он работает за куб, что для Форда-Беллмана является худшим случаем в плотных графах).

**Основная идея**

Подход похож на Форда-Беллмана, но индекс $K$ означает другое. Массив расстояний $D(A, B, K)$ имеет три индекса. **$K$ здесь означает не количество шагов/ребер, а количество задействованных различных вершин** в качестве промежуточных точек. Например, $K$ — это когда мы рассматриваем пути, использующие только первые $K$ вершин графа в качестве промежуточных.

**Реализация и Асимптотика**

Алгоритм реализуется с использованием трех вложенных циклов (полный перебор).

1. Цикл по $K$ (промежуточная вершина, от 0 до $V-1$).
2. Цикл по $A$ (стартовая вершина).
3. Цикл по $B$ (конечная вершина). Асимптотика работы — **$O(V^3)$**.

**Оптимизация**

Поскольку расстояние $D_k(A, B)$ всегда меньше либо равно $D_{k-1}(A, B)$ (добавление промежуточной вершины не может ухудшить путь), нет необходимости хранить старые слои. Можно хранить обычную матрицу $V \times V$ и пересчитывать значения "вслепую".

**Обнаружение отрицательных циклов**

Отрицательный цикл обнаруживается, если после всех пересчетов:

- На диагонали матрицы (расстояние от вершины $A$ до $A$) вы получили **значение, меньшее нуля**.
- По умолчанию, расстояние от вершины до самой себя равно нулю (при условии, что петли запрещены). Если оно стало меньше нуля, это означает, что найден цикл, уменьшающий стоимость.