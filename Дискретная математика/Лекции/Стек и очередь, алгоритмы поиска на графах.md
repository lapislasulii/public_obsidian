
## I. Линейные структуры данных

Линейная структура данных — это структура, которая поддерживает всего две основные операции: `Push` (добавление элемента) и `Pop` (извлечение элемента). В такой структуре отсутствует индексация.

**Пояснение простым языком:** Представьте себе линейную структуру как ящик с одной дверью (или два конца, если это очередь), через которую вы можете класть и доставать предметы. Вы не можете обратиться к предмету, который находится в середине, используя его номер или индекс.

Существует два основных способа организации линейных структур:

1. **FIFO** (First Input, First Output).
2. **FILO** (First Input, Last Output).

### A. Стек (Stack) — Принцип FILO

Стек реализует принцип **FILO (First In, Last Out)**: элемент, который вошел раньше, выйдет позже.

**Интуитивное понимание (FILO):** Представьте **магазин автомата Калашникова**. Если вы закладываете патроны в пустую обойму, патрон, который вы заложили раньше всех (он оказывается в самом низу), выстрелит позже всех (последним). Патронник автомата Калашникова, таким образом, является стеком.

#### Реализация Стека

Самый популярный способ реализации стека — **динамический массив**. Например, в языке Python массивы по умолчанию реализованы как динамические.

1. **Операции:**
    
    - `Push`: Добавляет элемент (например, **в конец** массива).
    - `Pop`: Извлекает элемент (с **конца** массива).
    - Операция `Pop` выполняется очень быстро, за $O(1)$ (константное время работы).
2. **Амортизированная стоимость (Push):**
    
    - Операция `Push` почти всегда выполняется за $O(1)$.
    - Проблема возникает, когда массив заполнен (например, 100 ячеек), и нужно добавить 101-й элемент (происходит выход за пределы текущего размера).
    - **Решение:** Вместо того чтобы просто добавить элемент, массив **перекопируется** в новый участок памяти увеличенного размера (например, в 1,5 или 2 раза больше). Эта переаллокация необходима для того, чтобы гарантировать, что все элементы нового массива лежат **рядом** в памяти, иначе индексация будет нарушена.
    - **Пояснение простым языком (Амортизация):** Перекопирование — это как переезд из маленькой квартиры в большую. Это дорого и долго, но вы делаете это редко. Поскольку вы увеличиваете размер массива в фиксированное количество раз (например, удваиваете его), эта дорогая операция происходит тем реже, чем больше элементов вы уже добавили. Если посчитать среднюю стоимость $N$ операций `Push`, она будет $O(1)$.

_(Лекция содержит обширное лирическое отступление о работе оперативной памяти, страничной индексации, различиях скоростей процессора и памяти, а также о технологии DDR (Double Data Rate), которая использует множественные сигналы для увеличения пропускной способности памяти, поскольку оперативка очень медленна по сравнению с процессором.)_

### B. Очередь (Queue) — Принцип FIFO

Очередь реализует принцип **FIFO (First In, First Out)**: элемент, который вошел раньше, выйдет раньше.

**Интуитивное понимание (FIFO):** Представьте **ленту пулемета**. Патрон, положенный в ленту первым, будет выстрелен первым.

#### Реализация Очереди

Реализация очереди использует выделенный кусок памяти с двумя указателями: **начало очереди (Start, S)** и **конец очереди (End, E)**.

1. **Операции:**
    
    - `Push`: Добавляет элемент в **конец** очереди и смещает указатель $E$ на $+1$.
    - `Pop`: Извлекает элемент с **начала** очереди и смещает указатель $S$ на $+1$.
2. **Управление памятью (Сдвиг):**
    
    - Если указатель начала $S$ достигает некоторой демаркационной линии (например, середины выделенной памяти), это означает, что в памяти за $S$ находится "мусор" (старые, удаленные элементы), а элементы очереди хранятся в конце выделенного блока.
    - В этом случае происходит процедура **сдвига**: элементы очереди физически перемещаются к началу выделенного куска памяти.
    - **Пояснение простым языком (Сдвиг):** Если вы постоянно добавляете элементы в конец и удаляете их из начала (например, делаете много `Push-Pop`), очередь постоянно "ползет" по памяти, и впереди остается много неиспользуемого пространства. Чтобы не тратить огромное количество памяти на хранение, например, всего одного элемента, массив периодически сдвигается, чтобы "уплотниться".

---

## II. Алгоритмы поиска на графах (DFS и BFS)

Алгоритм предназначен для нахождения кратчайших маршрутов из стартовой вершины $S$ до всех остальных вершин в **невзвешенном графе**.

Алгоритм использует следующие вспомогательные массивы:

- **$D$ (Distance):** Расстояние от стартовой вершины до вершины $i$. Изначально устанавливается в бесконечность.
- **$V$ (Visited/Увиденные):** Флаг, показывающий, был ли маршрут из $S$ в вершину $i$ (True/False).
- **$P$ (Parent):** Вершина-родитель, необходимая для восстановления кратчайшего маршрута.

Начальная инициализация: $D_S = 0$. Стартовая вершина $S$ добавляется в специальный **Контейнер** (линейная структура с операциями `Push/Pop`).

Основная логика алгоритма: Пока **Контейнер не пуст**:

1. Извлекается текущая вершина $Current$ (`Container.Pop()`).
2. Для каждого соседа $N$ вершины $Current$:
    - Если $N$ еще не была добавлена в Контейнер ($V_N$ = False):
        - $N$ добавляется в Контейнер (`Container.Push(N)`).
        - Устанавливается флаг $V_N = 1$ (вершина "увидена").
    - Проверяется, можно ли дойти до $N$ быстрее, чем текущее известное расстояние ($D_{Current} + 1 < D_N$).
    - Если да, то расстояние $D_N$ обновляется, и вершина $P_N$ (родитель) устанавливается как $Current$.

### A. Поиск в ширину (BFS — Breadth-First Search)

При использовании **Очереди (Queue)** в качестве Контейнера алгоритм реализует **Поиск в ширину (BFS)**.

- **Принцип:** BFS обходит вершины в порядке возрастания расстояния от стартовой вершины (сначала все вершины на расстоянии 1, затем на расстоянии 2 и т.д.).
- **Интуитивное понимание:** BFS работает как волна или расширяющийся круг. Мы ищем вширь, прежде чем углубляться.
- **Применение:** BFS является лучшим алгоритмом для **нахождения кратчайшего расстояния** в невзвешенном графе и для определения, существует ли маршрут из $A$ в $B$.
- **Оптимальность:** В BFS, как только вершина рассмотрена, вы **уже получили оптимальное кратчайшее расстояние** до нее. Это позволяет остановить алгоритм, как только найдена целевая вершина.

### B. Поиск в глубину (DFS — Depth-First Search)

При использовании **Стека (Stack)** в качестве Контейнера алгоритм реализует **Поиск в глубину (DFS — Depth-First Search)**.

- **Принцип:** DFS имеет приоритет выбора самой **удаленной вершины** от исходной (при прочих равных). Он идет максимально глубоко по одному пути.
- **Интуитивное понимание:** DFS — это как луч прожектора, направленный в одну сторону, который исследует весь этот путь, пока не упрется, а затем возвращается, чтобы исследовать следующий путь.
- **Применение:** DFS позволяет выполнять задачи, недоступные для BFS:
    1. **Топологическая сортировка:** Наделение вершин в ориентированных **ациклических графах** порядковыми номерами. Если из вершины $U$ есть путь в $V$, то номер $U$ должен быть больше номера $V$.
        - _Полезность:_ Используется, например, для определения порядка, в котором должны быть скомпилированы или загружены файлы, зависящие друг от друга (как в операциях `import` в Python).
    2. **Определение компонент сильной связности (Strongly Connected Components):** Для этого требуется два запуска DFS — один на исходном графе, и один на графе с развернутыми ребрами, начиная с последней обойденной вершины первого DFS.

---

## III. Сравнение структур и алгоритмов

|Структура|Принцип|Название в контексте поиска на графах|Основное применение|
|:-:|:-:|:-:|:-:|
|**Очередь (Queue)**|**FIFO** (First In, First Out)|**BFS** (Поиск в ширину)|Кратчайший путь в невзвешенном графе.|
|**Стек (Stack)**|**FILO** (First In, Last Out)|**DFS** (Поиск в глубину)|Топологическая сортировка, SCC.|

**Примечание о Deque (Двусторонняя очередь):** Двусторонняя очередь (DQE, Deque) может использоваться, так как она универсальна и умеет делать четыре операции вместо двух (`Push/Pop` с двух сторон). Однако с точки зрения скорости и математической оптимизации, DQE не может быть быстрее, чем специально реализованный стек или очередь. BFS, как правило, является более оптимальным для большинства классических задач нахождения расстояния или возможности достижения вершины, чем DFS.

**Аналогия для различия BFS и DFS:** Представьте, что вы ищете определенного человека в большом многоэтажном здании (граф).

- **BFS (Очередь/Ширина)**: Вы методично проверяете всех людей на первом этаже, затем всех на втором этаже, затем всех на третьем. Вы гарантированно найдете человека, используя минимальное количество шагов (кратчайшее расстояние).
- **DFS (Стек/Глубина)**: Вы заходите на первый этаж и сразу поднимаетесь по лестнице в самый дальний угол здания (например, на 10-й этаж), проверяя всех там. Если человека там нет, вы спускаетесь на один этаж и ищете в другой ветке, пока не вернетесь к началу. Вы быстро исследуете один глубокий путь.