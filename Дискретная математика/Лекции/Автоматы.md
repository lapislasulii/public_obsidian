1. Разрешимость и проблемы вычислений

**Основное понятие: Разрешимость**

Разрешимость (разрешимость) – это общий термин в математике, описывающий все бинарные классификаторы, то есть задачи, которые имеют только два варианта ответа: «да» или «нет». _Интуитивное пояснение:_ Разрешимость означает, что для любого случая можно дать гарантированный однозначный ответ, например, сказать, истинна или ложна логическая формула при заданном наборе аргументов, или есть ли корни у квадратного уравнения.

Разрешимость начинает «сыпаться» (становится неоднозначной) в задачах, ограниченных по ресурсам. Например, чтобы определить количество компонент связности в графе, обычно требуется обойти минимум все вершины, что делает невозможным выполнение задачи быстрее.

Проблемы с разрешимостью также возникают в сложной логике, такой как интуиционистская логика, где не всегда выполняется аксиома исключённого третьего (утверждение, что нечто либо есть, либо его нет).

**Проблема останова (завершаемость программы)**

Глобальная особенность компьютерных вычислений состоит в том, что на вход подается строка битов и на выход получается строка битов, при этом происходит изменение состояния программы, и она либо завершается, либо нет.

Проблема в том, что задача определения, завершится ли произвольная программа или нет, является неразрешимой. _Интуитивное пояснение:_ Не существует такого анализа (для Тьюринг-полного языка), который мог бы гарантированно определить, завершится ли программа. Единственный способ избежать этой проблемы — ограничить сам язык, лишив его Тьюринг-полноты.

**Тьюринг-полнота** – это описание мощности алгоритмов, которые может реализовать язык.

### 3. Формальные языки

В разделе теории автоматов изучается, как определить для некоторых формальных языков их слов, подходят они под заданные правила или нет.

**Формальный язык** отличается от естественного (неформального) тем, что он был сначала формализован математически, а затем создан (например, в отличие от русского языка). Формальный язык должен иметь заданные правила, их конечное количество, и они должны быть непротиворечивыми.

**Компоненты формального языка:**

1. **Алфавит языка (нетерминальные символы):** Набор символов, который почти всегда должен быть конечен. В контексте языков программирования это могут быть все буквы, цифры и символы, используемые для переменных.
2. **Правила перехода:** Правила, определяющие способы словообразования. Количество правил перехода должно быть конечным — это базовый минимум. _Интуитивное пояснение:_ Правила перехода можно сравнить с грамматическими правилами в русском языке, но в формальном языке они должны быть строгими и конечными.

**Пример: Язык правильных скобочных последовательностей (ЯПСП)**

- **Алфавит:** Открывающая скобка (S1) и закрывающая скобка (S2).
- **Слово:** Последовательность скобок, например, `()()`.
- **Правильность (Алгоритм разрешимости):** Слово считается правильным, если:
    1. При движении вдоль строки баланс (количество открывающих минус количество закрывающих скобок) никогда не становится отрицательным.
    2. Баланс в конце строки равен нулю.
- **Правила вывода:**
    - Если $L$ — правильная последовательность, то $(L)$ тоже правильная.
    - Если $L_1$ и $L_2$ — правильные последовательности, то $L_1L_2$ тоже правильная.
    - Пустое слово (содержащее ноль символов) является правильной скобочной последовательностью.

### 4. Уровни формальных языков (Иерархия грамматик)

Существует 3.5 уровня градации формальных языков.

1. **Регулярные выражения (РВ):** Базовый уровень автоматов. РВ — это способ записи символов через подходящие маски.
    
    - **Операторы:** Используются метасимволы (квантификаторы), такие как `*` (ноль или много), `?` (ноль или один), `+` (один или больше), а также выбор символов (например, в квадратных скобках).
    - _Инсайт:_ Язык правильных скобочных последовательностей не может быть выражен через регулярные выражения, так как РВ слабее других грамматик.
2. **Контекстно-свободные грамматики (КСГ):** Следующий уровень крутости, который имеет свойство, что правила перехода определяются либо одним общим символом, либо приписывание нетерминальных символов происходит только справа (R-грамматики) или только слева (L-грамматики).
    
3. **Контекстно-зависимые грамматики (КЗГ):** Третья градация. Почти все языки программирования (за исключением, возможно, C++) не являются контекстно-зависимыми грамматиками.
    

Все, что не попадает в эти три класса (например, языки с бесконечным количеством правил или противоречивыми правилами), технически уже не является формальными языками.

### 5. Конечные автоматы (Finite Automata)

Конечные автоматы используются для решения задачи о разрешимости регулярных выражений. Автомат представляет собой граф, в котором состояния (вершины) соответствуют тому, сколько правильных символов было считано.

- **Начальное состояние (S0/Q0):** Соответствует состоянию пустой строки.
- **Терминальные состояния:** Вершины, обозначающие успешное завершение, отмечаются двойной обводкой. Если переход останавливается в нетерминальной вершине, ответ «нет».
- **Состояние ошибки (Error state/Fail state E):** Особое состояние, куда попадает автомат, если считывает некорректный символ. Если автомат попадает в состояние ошибки, и дальше он считывает символы, он остается в ошибке (петля).
    - _Договоренность:_ Неявные переходы, которые не указаны, автоматически ведут в неявное состояние ошибки.

#### 5.1. Детерминированный конечный автомат (ДКА)

**Определение ДКА:** Это такой конечный автомат, в котором из каждой вершины исходит ровно $N$ рёбер, каждое из которых уникально по весу, где $N$ — количество элементов алфавита. _Интуитивное пояснение:_ В ДКА путешествие детерминировано: на каждом шаге мы точно знаем, куда идти, поскольку для каждого символа из алфавита существует только один путь из текущей вершины.

- Автомат, моделирующий работу, запускается один раз, и одна ошибка приводит к завершению с ошибкой (аналогия с жизнью: "один раз ошиблись и всё").

#### 5.2. Недетерминированный конечный автомат (НКА)

**Определение НКА:** Конечный автомат, который не является детерминированным. _Интуитивное пояснение:_ НКА позволяет неоднозначность:

1. Возможность нескольких переходов из одной вершины по одному и тому же символу.
2. Возможность перехода по пустому символу (ε-переходы), позволяющие менять состояние автоматически, подбирая удобный путь.

При работе с НКА необходимо рассматривать все возможные случаи, придерживаясь **оптимистичного сценария** (пытаясь найти максимальное количество слов, которые подходят под автомат).

- **Соотношение ДКА и НКА:** НКА проще создавать, чем ДКА, но с ними неудобно работать.
    - **Алгоритм Томпсона:** Позволяет преобразовать любой НКА в эквивалентный ДКА, хотя сам алгоритм "крайне душный".
    - **Теорема Клини:** Доказывает, что любое регулярное выражение может быть выражено через ДКА, и любой ДКА может быть представлен в виде регулярки.
    - _Интуитивное пояснение:_ Это означает, что регулярные выражения, ДКА и НКА описывают один и тот же класс формальных языков.

### 6. Автоматы с магазинной памятью (Pushdown Automata - PDA)

Для работы с контекстно-свободными грамматиками (например, языком правильных скобочных последовательностей), которые не могут быть выражены регулярными выражениями, были придуманы автоматы с магазинной памятью (стековые автоматы).

- **Принцип работы:** Автомат с магазинной памятью буквально создан для отслеживания баланса структур.
- **Стек (Магазинная память):** На каждом переходе, помимо считывания символа, выполняется одна из трех операций с магазинной памятью:
    1. Добавить символ (push).
    2. Извлечь символ (pop).
    3. Ничего не делать.
- **Успешное завершение:** Происходит, если вводная строчка обработана и магазин пуст.
- **Некорректная операция:** Если произошла попытка извлечь элемент из пустого магазина, это автоматический фейл.

_Интуитивное пояснение:_ Для проверки правильности скобочной последовательности, автомат может делать **push** при каждой открывающей скобке и **pop** при каждой закрывающей. Если в конце все скобки, которые были открыты, закрыты (стек пуст), и при этом ни разу не пытались извлечь символ из пустого стека (баланс не нарушен), то последовательность корректна.

---

**Аналогия для различия ДКА и НКА:** Представьте, что вам нужно пройти лабиринт (автомат). **ДКА (Детерминированный конечный автомат)** — это лабиринт с четкими указателями: на каждой развилке есть только одна дверь для каждого символа (инструкции), и вы точно знаете, куда идете. **НКА (Недетерминированный конечный автомат)** — это лабиринт, где на одной развилке может быть две двери с одинаковой пометкой (символом), и вы должны идти сразу в обе (рассматривая все возможные пути), а еще есть невидимые порталы (переходы по пустому символу), которые переносят вас без предупреждения. Чтобы "выиграть" (принять слово), достаточно, чтобы хотя бы один из ваших клонов дошел до выхода.

**Аналогия для Автомата с магазинной памятью:** Если конечный автомат (ДКА/НКА) подобен калькулятору, который может помнить только конечное количество состояний (например, только последнее действие), то **автомат с магазинной памятью** подобен калькулятору с дополнительной стопкой бумаг (стеком), где он может складывать и извлекать записи по принципу "последний пришел, первый ушел" (LIFO), что позволяет ему отслеживать глубокие вложенные структуры, такие как баланс скобок.