[[Презентация лекции Базовые структуры]]

### 1. Почему C, а не Python

Выбор языка C (а не C++) обусловлен необходимостью глубокого понимания структур данных и производительности.

1. **Сложность в Python:** Внешне простые операции в Python, такие как преобразования типов (например, использование `set` или `dict` в функциях), могут скрывать внутренние циклы и массивы в исходниках языка.
2. **Асимптотика:** Использование таких преобразований внутри циклов может катастрофически увеличить асимптотическую сложность, например, с O(N²) до O(N³).
3. **Неявное управление памятью:** Python, в отличие от C, автоматически выполняет много неявных операций, которые затрудняют точный анализ производительности и использования памяти.

### 2. Важность понимания памяти

Понимание базовых типов и их размеров в памяти критически важно при работе с большими данными, особенно в сфере Machine Learning.

- **Экономия памяти:** В примере с набором данных "Chess Games" показано, что если **не следить за типами**, объем данных может достигать **7.21 ГБ**. Если же внимательно подобрать типы (например, использовать `int16` вместо `int64`), объем сокращается почти вдвое — до **3.90 ГБ**.

### 3. Базовые типы данных в C

В лекции подробно рассмотрены размеры базовых типов в C (ориентировочно для 64-разрядной системы) и сравнение их с реализацией в Python.

#### 3.1. Булевы типы (`bool`)

|Конструкция в C|Размер в байтах|Примечание|
|:--|:--|:--|
|`sizeof(true)`/`sizeof(false)`|4 байта|Может транслироваться в `int`.|
|`sizeof(_Bool)` / `sizeof(bool)`|1 байт|Стандарт C99.|
|Переменная `bool`|1 байт|Переменные типа `bool` занимают 1 байт.|
|Статический массив `bool arr`|10 байт|Занимает $N$ байт для $N$ элементов.|
|Указатель на динамический массив `bool* arr`|8 байт|Указатель — это `long long`, который весит 8 байт.|

**Булевы типы в Python:**

- `True` и `False` в Python являются **константами**, которые хранятся в одном месте памяти, а переменные просто ссылаются на них.
- Размер самого объекта `True` или `False` составляет **28 байт**.
- Массив (лист) булевых значений в Python занимает намного больше места (в 7-8 раз) по сравнению с C, так как он хранит не сами значения, а **8-байтовые указатели** на эти объекты.

#### 3.2. Целочисленные типы (`Integer` в C)

- Размерность и диапазон значений зависят от количества бит. Диапазон вычисляется как $2^{\text{бит}}$.
- `int` по умолчанию занимает **4 байта** (32 бита).
- Если число превышает максимальное значение для 4-байтового `int` (например, 2,147,483,648), компилятор автоматически выделяет **8 байт** (тип `long`).
- Типы с указанной битностью: `int8_t` (1 байт), `uint8_t` (1 байт), `short int` (2 байта), `long` (8 байт), `long long` (8 байт).
- Массив `int arr` занимает **40 байт**.

**Целочисленные типы в Python:**

- Размер `int` в Python варьируется (например, 1 занимает 28 байт, $10^{36}$ — 40 байт).
- Python `int` может вмещать **бесконечно большое число**, поскольку реализован как псевдомассив (массив из нескольких 64-битных элементов).
- Массив (лист) из миллиона `int` чисел в Python весит примерно **в 5 раз больше**, чем в C, из-за хранения указателей.

#### 3.3. Числа с плавающей точкой (`Float` и `Double`)

- Компиляторы C используют стандарт **IEEE 754**.
- Числа хранятся приблизительно, используя **экспоненту** (для порядка/степени) и **мантиссу** (дробная часть).
- `float`: **32 бита (4 байта)**: 1 бит знака, 8 бит экспоненты, 23 бита мантиссы.
- `double`: **64 бита (8 байт)**: 1 бит знака, 11 бит экспоненты, 52 бита мантиссы.
- Использование этих типов может привести к потере точности, особенно на 4-м знаке после запятой для `float`.
- Массив `double` в Python весит примерно **в 4 раза больше**, чем в C.

#### 3.4. Символы и строки (`Char and String` в C)

- В C **одинарные кавычки** (`'a'`) обозначают символ (`char`), а **двойные кавычки** (`"hello"`) — строку (массив символов).
- Переменная типа `char` занимает **1 байт**.
- Размер символьного литерала (`sizeof('a')`) может быть **4 байта** (как `int`) из-за автоматического преобразования компилятором.
- **Строка** в C — это массив символов, который обязательно завершается **нулевым символом** (`\0`). Функции работы со строками (например, из `string.h`) ориентируются на этот завершающий символ.
    - Строка `"hello"` (5 символов) занимает **6 байт**.
- **Кириллица:** Для работы с кириллицей, которая может требовать 2 байта на символ, используется префикс `L` перед символом или строкой (например, `L'ы'`).
    - Строка `"Привет"` (6 символов) занимает $6 \times 2 + 1 = **13 байт**.

**Строки в Python:**

- Размеры строк в Python нелогичны и большие (пустая строка — 41 байт; символ 'ы' — 60 байтов), что объясняется сложной внутренней структурой объектов Python.

### 4. Указатели и ссылки

**Указатель** — это переменная, которая хранит адрес ячейки памяти.

- На 64-битных системах указатель всегда весит **8 байт** (`long long`), так как этот размер способен вместить любой возможный адрес памяти.
- Оператор **амперсанд** (`&`) используется для получения адреса переменной (взятие ссылки).
- **Расположение в памяти:**
    - **Стек (Stack):** Хранит локальные переменные, растет от старших адресов к младшим.
    - **Куча (Heap):** Динамически выделяемая память, растет от младших адресов к старшим.
- **Арифметика указателей:** При добавлении или вычитании числа к указателю (например, `pointer + 1`), происходит **смещение** указателя не на 1 байт, а на **размер типа данных**, на который он указывает.
    - Если `short int` (2 байта) находится по адресу `0x16f702e06`, то `(pointer - 1)` сместится на 2 байта и будет указывать на `0x16f702e04`.

### 5. Структуры (`Structs`)

**Структуры** — это способ группировки объектов.

- Структуры используют выравнивание данных (padding), что может привести к увеличению общего размера структуры, даже если сумма размеров ее членов меньше.
- **Примеры размеров структур (из-за выравнивания):**
    - `struct A {int x;}`: 4 байта.
    - `struct B {char c; int x;}`: 8 байт (хотя 1 + 4 = 5 байт).
    - `struct C {int x; char c;}`: 8 байт (хотя 4 + 1 = 5 байт).
    - `struct D {char c; double d;}`: 16 байт (1 + 8 + padding).
- Пример структуры для вектора включает поля `void *data`, `size_t size`, `size_t elem_size`, `size_t capacity`.

### 6. Задания для тренировки

В рамках подготовки к 3-й лабораторной работе предложены 15 задач на указатели, разделенные на три уровня сложности (Базовые, Средние, Продвинутые). Решение этих задач не является обязательным, но рекомендуется для развития навыков работы с указателями и динамической памятью.

**Внимание:** Продвинутые задания (11–15) предназначены для тех, кому "скучно", и включают работу с указателями на указатели (например, реализация двумерных динамических массивов).