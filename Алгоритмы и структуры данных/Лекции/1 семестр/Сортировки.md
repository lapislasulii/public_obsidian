[[Презентация лекции Сортировки]]
### 1. Введение и важность темы

Лектор подчеркивает, что изучение сортировок — это не просто академическая задача, а база для работы многих алгоритмов, например, бинарного поиска, который работает только на отсортированных данных. В реальной разработке (например, в Low-Code платформах для машинного обучения) неправильный выбор асимптотики (использование $O(N^2)$ вместо $O(N \log N)$) приводит к тому, что при росте нагрузки система начинает тратить минуты вместо секунд на обработку данных.

### 2. Классификация алгоритмов сортировки

Все алгоритмы можно разделить на несколько ключевых групп:

- **Простые (учебные):** Сложность $O(N^2)$, подходят для маленьких входных данных (Bubble, Insertion, Selection).
- **Эффективные (Divide & Conquer):** Сложность $O(N \log N)$, высокая производительность (Merge, Quick, Heap).
- **Линейные (без сравнения):** Используют дополнительную память, могут работать быстрее $O(N \log N)$ (Counting, Radix, Bucket).
- **Адаптивные:** Работают быстрее на почти отсортированных данных (Insertion, Timsort).

### 3. Простые алгоритмы ($O(N^2)$)

Эти алгоритмы характеризуются пространственной сложностью **$O(1)$**, так как не требуют дополнительной памяти.

- **Сортировка пузырьком (Bubble Sort):** Стабильный алгоритм, основанный на переборе всех комбинаций и замене соседних элементов местами. Его сложность всегда $O(N^2)$, так как в базовой реализации всегда присутствуют два вложенных цикла, независимо от состояния входных данных.
- **Сортировка вставками (Insertion Sort):** Гениальная оптимизация пузырька. Она игнорирует уже отсортированную часть массива и двигает текущий элемент влево до нужной позиции. В лучшем случае (на отсортированных данных) работает за **$O(N)$**, в худшем — за **$O(N^2)$**.

### 4. Эффективные алгоритмы ($O(N \log N)$)

- **Сортировка слиянием (Merge Sort):** Рекурсивный алгоритм. Массив делится пополам до тех пор, пока не останутся части из 1-2 элементов, которые затем сливаются в правильном порядке.
    - **Сложность:** Всегда стабильно **$O(N \log N)$**.
    - **Минус:** Требует дополнительную память **$O(N)$** для временных массивов при слиянии.
- **Быстрая сортировка (Quick Sort):** Выбирается опорный элемент (pivot), относительно которого массив делится на три части: меньше, равные и больше опорного.
    - **Сложность:** В среднем **$O(N \log N)$**, но при неудачном выборе опорного элемента (например, если он всегда минимальный или максимальный) может деградировать до **$O(N^2)$**.
    - **Оптимизация (V2):** В продвинутой версии может работать без выделения дополнительной памяти (**$O(1)$**), переставляя элементы внутри исходного массива.

### 5. Линейные сортировки и сложные случаи

- **Сортировка Шелла (Shell Sort):** Модификация сортировки вставками, использующая «шаги» (gaps). Сложность сильно зависит от выбранной последовательности шагов (Кнут, Седжвик и др.) и может быть лучше $O(N^2)$, но хуже $O(N \log N)$.
- **Сортировка подсчетом (Counting Sort):** Работает за линейное время, если диапазон значений (K) невелик.
- **Радарная (разрядная) сортировка (Radix Sort):** Сортирует числа по разрядам (единицы, десятки и т.д.). Эффективна, но требует дополнительной памяти.

### 6. Важные концепции и анализ

- **Стабильность:** Это сохранение изначального порядка ключей с одинаковыми значениями. Например, быстрая сортировка — нестабильная, а слиянием — стабильная.
- **Оценка производительности:** Для корректного сравнения алгоритмов лектор рекомендует использовать **boxplot («ящик с усами»)**. Это позволяет увидеть среднее время, доверительный интервал и аномалии (выбросы), что гораздо точнее простого среднего значения.

**Итог:** В современных языках программирования по умолчанию часто используются модификации **Merge Sort** или **Quick Sort**.

---

**Аналогия для понимания:** Представьте сортировку книг в библиотеке.

- **Пузырек** — это если бы вы каждый раз проходили вдоль всей полки и меняли две соседние книги, пока всё не станет на места.
- **Слияние** — это если бы вы разделили все книги на маленькие стопки, рассортировали их по отдельности, а потом аккуратно объединяли стопки, всегда выбирая из двух верхних книг ту, что должна идти раньше.
- **Быстрая сортировка** — это выбор одной книги «эталона» и разделение всех остальных на тех, что «левее» и «правее» неё, с повторением процесса для каждой группы.