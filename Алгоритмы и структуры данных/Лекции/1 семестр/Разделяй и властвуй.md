[[Презентация лекции Разделяй и Властвуй]]
### 1. Введение в метод «Разделяй и властвуй» (Divide and Conquer)

Метод **«Разделяй и властвуй»** — это фундаментальная парадигма в программировании и алгебре, которая позволяет решать сложные задачи путем их декомпозиции на более простые подзадачи.

Процесс решения состоит из трех основных этапов:

1. **Разделение:** разбиение исходной задачи на несколько подзадач меньшего размера.
2. **Властвование (Решение):** рекурсивное решение этих подзадач. Если размер подзадачи достаточно мал (базовый случай), она решается непосредственно.
3. **Комбинирование (Слияние):** объединение результатов решенных подзадач для получения финального решения исходной задачи.

Примеры алгоритмов, использующих этот подход: бинарный поиск, быстрая сортировка (Quick Sort), сортировка слиянием (Merge Sort) и алгоритм Штрассена для умножения матриц.

---

### 2. Рекуррентные соотношения и асимптотика

Для оценки сложности рекурсивных алгоритмов используются **рекуррентные соотношения** — уравнения или неравенства, которые описывают функцию через её значения для меньших аргументов.

Типичный вид рекуррентного соотношения: $$T(n) = aT(n/b) + f(n)$$ Где:

- **$a$** — количество подзадач.
- **$n/b$** — размер каждой подзадачи.
- **$f(n)$** (или $\Theta(n^d)$) — стоимость этапов разделения и комбинирования (пред/пост-обработка).

Для оценки используются следующие нотации:

- **$O$-нотация:** описывает верхнюю границу сложности (худший случай).
- **$\Theta$-нотация (Тета):** описывает точную асимптотическую сложность (ограничена и сверху, и снизу).

---

### 3. Методы решения рекуррентных соотношений

В лекции выделяются три основных способа определения сложности:

#### А. Метод деревьев (Recursion-Tree Method)

Рекуррентное соотношение преобразуется в дерево, где узлы представляют стоимость на разных уровнях рекурсии.

- Для каждого уровня $i$ рассчитывается количество подзадач, их размер и суммарная выполненная «работа».
- Общая сложность находится как сумма работы на всех уровнях от $0$ до $k$ (глубина дерева).
- **Пример Quick Sort (средний случай):** $T(n) = 2T(n/2) + O(n)$. Сумма работы на каждом уровне дает $n \cdot \log n$, что приводит к сложности $\Theta(n \log n)$.

#### Б. Основная теорема (Master Theorem)

Предоставляет готовые формулы для решения соотношений вида $T(n) = aT(n/b) + O(n^d)$. Существует три основных случая в зависимости от соотношения $d$ и $\log_b a$:

1. **Если $d > \log_b a$:** сложность определяется стоимостью разделения/комбинирования — $O(n^d)$.
2. **Если $d = \log_b a$:** сложность — $O(n^d \log n)$.
3. **Если $d < \log_b a$:** сложность определяется количеством подзадач — $O(n^{\log_b a})$.

#### В. Метод подстановок (Substitution Method)

Основан на выдвижении предположения о границе сложности с последующим доказательством методом математической индукции. Если неравенство при подстановке сходится, предположение верно.

---

### 4. Оптимизация вычислений и алгоритм Карацубы

Лектор подчеркивает важность **побитовых операций** для оптимизации. Побитовый сдвиг влево ($<<$) эквивалентен умножению на $2^k$, а сдвиг вправо ($>>$) — делению на $2^k$. Эти операции выполняются за один такт процессора, что значительно быстрее обычного деления.

**Алгоритм Карацубы** использует «Разделяй и властвуй» для умножения чисел быстрее, чем «в столбик».

- Вместо четырех рекурсивных умножений он сводит задачу к **трем**, используя математические преобразования и побитовые сдвиги.
- Рекуррентное соотношение: $T(n) = 3T(n/2) + O(n)$.
- Итоговая асимптотика составляет примерно $O(n^{1.58})$, что эффективнее классического $O(n^2)$.

---

### 5. Анализ других алгоритмов

1. **Бинарный поиск:** $T(n) = T(n/2) + O(1)$. Одна подзадача вдвое меньше, константная обработка. Результат: $O(\log n)$.
2. **Умножение матриц (метод Штрассена):** Сокращает количество умножений подматриц с 8 до 7. Рекуррентное соотношение: $T(n) = 7T(n/2) + O(n^2)$. По основной теореме сложность составляет $O(n^{\log_2 7}) \approx O(n^{2.8})$.
3. **Худший случай Quick Sort:** Возникает при неудачном выборе опорного элемента (например, когда массив уже отсортирован). Дерево вырождается в список глубиной $n$, а работа на каждом уровне составляет $O(n)$, что приводит к сложности $O(n^2)$.

---

**Аналогия для понимания:** Представьте, что вам нужно построить огромный замок из конструктора. Метод **«Разделяй и властвуй»** — это стратегия, при которой вы не пытаетесь собрать всё сразу, а раздаете инструкции десяти друзьям (разделение), чтобы каждый собрал по одной башне (решение подзадач), а затем вы просто соединяете готовые башни вместе (комбинирование). **Рекуррентное соотношение** в этом случае — это ваша математическая формула, позволяющая рассчитать, сколько времени займет стройка в зависимости от количества друзей и сложности соединения деталей.