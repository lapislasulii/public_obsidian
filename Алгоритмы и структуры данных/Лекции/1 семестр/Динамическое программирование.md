[[Презентация лекции Динамическое программирование]]
### 1. Введение в динамическое программирование (ДП)

**Динамическое программирование** — это метод решения сложных задач путем их разбиения на более простые подзадачи, результаты которых сохраняются для предотвращения повторных вычислений. Этот подход наиболее эффективен в задачах оптимизации и комбинаторики, где одни и те же расчеты могут возникать многократно.

**Основные признаки задачи, решаемой с помощью ДП:**

- **Оптимальная подструктура:** оптимальное решение всей задачи строится на основе оптимальных решений её подзадач.
- **Перекрывающиеся подзадачи:** многие подзадачи повторяются, что позволяет сохранить результат один раз и использовать его снова.
- **Накопление решений:** необходимость хранения результатов в структуре данных (массиве или матрице) для переиспользования,.

В отличие от метода «разделяй и властвуй», где задача просто дробится на части, ДП делает акцент на **накоплении и повторном использовании** знаний, что экономит время, но требует больше оперативной памяти,.

---

### 2. Расстояние Левенштейна (Редакторское расстояние)

Одной из ключевых задач лекции стало вычисление **расстояния Левенштейна** — метрики сходства двух строк,. Она определяет минимальное количество операций, необходимых для превращения одной строки в другую.

**Допустимые операции,:**

1. **Вставка** символа.
2. **Удаление** символа.
3. **Замена** символа.

**Алгоритм заполнения таблицы (матрицы):**

- Для строк длиной $n$ и $m$ строится таблица размером $(n+1) \times (m+1)$,.
- Строки соответствуют символам слова **A**, столбцы — символам слова **B**,.
- **Инициализация:** пустая строка превращается в строку длиной $j$ за $j$ вставок, а строка длиной $i$ превращается в пустую за $i$ удалений.
- **Сравнение символов $i$ и $j$,:**
    - Если символы **совпадают**: значение просто копируется из диагонального элемента ($dp[i][j] = dp[i-1][j-1]$).
    - Если символы **не совпадают**: берется $1 + \min$ из трех соседних ячеек:
        - $dp[i-1][j] + 1$ (удаление);
        - $dp[i][j-1] + 1$ (вставка);
        - $dp[i-1][j-1] + 1$ (замена).

Результат вычислений находится в нижней правой ячейке таблицы. Этот метод широко применяется в системах проверки орфографии и OCR (распознавание текста) для компенсации ошибок сканирования,.

---

### 3. Задача о пути в сетке (Grid Path Problems)

Это класс задач, где нужно найти кратчайший путь или количество путей из точки X в точку Y на двумерной сетке с учетом препятствий.

**Два способа реализации:**

1. **Прямой путь (итеративный):** таблица заполняется последовательно с помощью циклов. Значение в текущей ячейке — это сумма (или минимум) значений соседей сверху и слева,.
2. **Обратный путь (рекурсивный):** вычисление идет от целевой точки к начальной с использованием мемоизации (сохранения уже вычисленных путей),.

Асимптотическая сложность такого решения обычно составляет $O(N \times M)$, так как мы проходим по каждой ячейке один раз. Однако использование **приоритетных очередей** (как в алгоритме Дейкстры) может оптимизировать процесс в некоторых случаях до $O(N \log N)$,.

---

### 4. Другие классические задачи ДП

В лекции были упомянуты другие типовые задачи, важные для практики и собеседований,:

- **Наибольшая возрастающая подпоследовательность (LIS):** поиск самой длинной цепочки элементов массива, которые идут в порядке возрастания,. Для решения создается массив длин, где для каждого элемента ищется максимум среди предыдущих подходящих элементов,.
- **Наибольшая общая подпоследовательность (LCS):** нахождение максимальной последовательности символов, общей для двух строк,.
- **Задача о поиске идеальных квадратов:** нахождение минимального количества целых чисел, квадраты которых в сумме дают число $n$,.
- **Задача о рюкзаке:** классика ДП, часто встречающаяся на экзаменах и вступительных испытаниях в магистратуру,.

---

### 5. Основные шаги реализации любого ДП

Для успешного решения задачи методом динамического программирования лектор выделил четыре этапа,:

1. **Определить подзадачу:** она должна быть минимальной и понятной (например, минимизация суммы).
2. **Инициализировать память:** выбрать структуру данных (массив/матрица) и задать базовые случаи.
3. **Заполнить таблицу:** прописать логику перехода от известных решений подзадач к новым.
4. **Взять результат:** итоговый ответ обычно находится в последнем элементе структуры.

**Важное замечание:** ДП — это не просто любой алгоритм с использованием условий `if`. Это именно система, построенная на **структурных подзадачах и переиспользовании памяти**,. Если вы просто перебираете варианты, это не динамическое программирование.

> **Метафора для закрепления:** Представьте, что вы строите высокую лестницу. Вместо того чтобы каждый раз прыгать с земли на самую верхнюю ступеньку (что невозможно), вы встаете на уже готовую предыдущую ступеньку и делаете один маленький шаг вверх. Динамическое программирование — это и есть процесс записи высоты каждой ступеньки, чтобы вам не нужно было перемерять всю лестницу заново при каждом шаге.