[[Презентация лекции хеш-таблицы 2]]
## 1. Обзор структур данных (Вспоминаем, что имеем)

Лекция начинается с обзора ключевых структур, используемых при реализации динамических структур данных, таких как хеш-таблицы:

- **`Node` (Узел):** Базовая единица связанного списка. Содержит указатель на данные (`void *data`) и указатель на следующий узел (`struct Node *next`).
- **`GenericList` (Связный список):** Содержит указатель на головной узел (`Node *head`) и размер элемента (`size_t elem_size`).
    - _Интуитивное понимание:_ Представьте **связный список** как цепь бусинок, где каждая бусинка знает, где найти следующую.
- **`Vector` (Вектор/Динамический массив):** Содержит указатель на данные (`void *data`), размер элемента (`size_t elem_size`), текущее количество элементов (`size`), и максимальную вместимость (`capacity`).
    - _Интуитивное понимание:_ Представьте **вектор** как плотно упакованный контейнер, где все элементы лежат впритык, один за другим, и вы можете мгновенно обратиться к любому элементу по его номеру.

## 2. Разбор вопросов по указателям и структурам (Разминка)

Значительная часть лекции посвящена практическим примерам на C, демонстрирующим работу с указателями, структурами, и арифметикой смещений (байтовая арифметика).

### Вопрос №1: Анализ смещения в структуре `GenericList`

**Структура:** `GenericList` содержит `Node *head` (обычно 8 байт) и `size_t elem_size` (обычно 8 байт). Общий размер структуры составляет **16 байт**.

**Код:** `printf("%d", *((char*)data + 8));`

1. **Выделение памяти:** `data = malloc(sizeof(GenericList))` выделяет 16 байт.
2. **Байтовая арифметика:** Указатель `data` приводится к типу `char*` (`(char*)data`) для обеспечения побайтового смещения, так как `char` занимает 1 байт.
3. **Смещение:** Смещение на 8 байт (`+ 8`) пропускает первое поле структуры (`Node *head`), которое занимает первые 8 байт.
4. **Чтение:** Разыменование `*` читает содержимое второго поля (`size_t elem_size`).
    - **Вывод в консоль:** Если память была только выделена, то там будет лежать **непонятное/случайное значение** (мусор), поскольку поле не инициализировано.
    - **Где ошибка:** Ошибка может возникнуть, если память не будет выделена (возврат `NULL` из `malloc`).

- _Интуитивное понимание:_ **Арифметика указателей через `char*`** — это как использование рулетки, измеряющей по одному миллиметру (байту), чтобы точно отмерить расстояние до конкретного поля внутри сложной коробки (структуры).

### Вопрос №2: Анализ `memcpy` и порядка байтов

Код копирует 1 байт (`char var2 = 2`) в начало `pt`, а затем 4 байта (`int var1 = 511`) со смещением в 1 байт.

- `printf("%d\n", *(char*)pt);`
    - **Вывод:** **2** (Читаем 1-й байт, куда записана `var2`).
- `printf("%d\n", *(int*)(pt + 1));`
    - **Вывод:** **511** (Читаем 4 байта, начиная со смещения 1, где записана `var1`).
- `printf("%d\n", *(unsigned char*)(pt + 1));`
    - **Вывод:** **255** (Читаем 1 байт со смещения 1. Число 511 ($2^8 + 2^7 + ... + 2^0 = 256 + 255$) состоит из двух байтов: 1 (старший) и 255 (младший). Так как память обычно читается с младших адресов, на 2-м байте (смещение +1) лежит 255).
- `printf("%d\n", *(unsigned char*)(pt + 2));`
    - **Вывод:** **1** (Читаем 1 байт со смещения 2. Это 3-й байт, который является старшим байтом числа 511, и там лежит 1).

## 3. Хеш-таблицы: Основы и Кортежи

**Хеш-таблица (Словарь)** — это структура данных, позволяющая выполнять поиск, вставку и удаление за очень быстрое время (в среднем $O(1)$).

**Как это работает?** Хеш-таблица по сути является **массивом**. Вместо того чтобы перебирать ключи, мы используем **хеш-функцию**, которая преобразует ключ (любой неизменяемый объект, например, строка или число) в **индекс массива**.

**Хеш-функция** — это одностороннее преобразование, которое должно давать **одинаковый результат для одинаковых входных данных**.

Для преобразования хеша в индекс используется операция: `index = hash(key) % capacity`.

### Кортеж (Pair) для хранения данных

Поскольку хеш-таблица хранит пары **ключ-значение** (Key-Value), необходимо хранить эти пары в ячейках массива.

**Кортеж (`GenericPair`)** — это неизменяемая (immutable) упорядоченная коллекция объектов. В C реализация может выглядеть как:

```
typedef struct {
   const void* key;
   const void* value;
} GenericPair;
```

Использование `const` в структуре, предназначенной для хранения данных с помощью `void*` и копирования через `memcpy`, может вызвать проблемы, так как компилятор запрещает запись в константное поле. В итоге, для гибкой реализации в C, предпочтение отдается хранению данных в непрерывной памяти без использования `const` для полей `void*`, куда нужно копировать данные.

## 4. Структура Хеш-таблицы и Варианты Хранения Пар

### Основная структура `HashTable`

Хеш-таблица должна хранить массив элементов (пар), а также метаданные для управления памятью:

```
typedef struct {
   Vector* values;       // Массив, содержащий пары ключ-значение
   const size_t key_size; // Размер ключа в байтах
   const size_t val_size; // Размер значения в байтах
   const size_t capacity; // Максимальная вместимость (размер массива)
} HashTable;
```

### Варианты хранения пар ключ-значение

При реализации в C, где мы работаем с `void*`, возникает вопрос, как хранить пары:

1. **Массив указателей на структуры (`GenericPair`)**: Каждый элемент массива (вектора) весит 16 байт (два указателя по 8 байт), и они указывают куда-то в другое место памяти, где лежат реальные ключ и значение.
    - _Плюсы:_ Универсально, легко работать с большими ключами/значениями.
    - _Минусы:_ Дополнительные накладные расходы (16 байт) на каждый элемент.
2. **Массив с непрерывной памятью (Последовательное хранение)**: Каждый элемент массива занимает **$K_{size} + V_{size}$** байт, где данные ключа и значения лежат последовательно друг за другом в памяти.
    - _Плюсы:_ Экономия памяти (нет лишних указателей), быстрее считывание.
    - _Минусы:_ Необходима большая непрерывная область памяти для `Vector` при больших ключах/значениях. Этот подход был выбран для демонстрации открытой адресации.

## 5. Метод разрешения коллизий: Открытая адресация

**Открытая адресация** (Open Addressing) — это метод, при котором все пары ключ-значение хранятся **непосредственно** в массиве хеш-таблицы. При коллизии (когда ячейка занята) мы ищем следующую свободную ячейку по определенному алгоритму (исследованию).

### Коэффициент заполнения ($\alpha$)

В открытой адресации **коэффициент заполнения** ($\alpha = \frac{size}{capacity}$) всегда должен быть **меньше 1** ($\alpha < 1$). Физически нельзя впихнуть больше элементов, чем есть ячеек.

- **Важность $\alpha$:** Чем выше $\alpha$, тем больше проверок (итераций) требуется для вставки или поиска. Например, при $\alpha = 0.5$, в среднем требуется **2 обращения**; при $\alpha = 0.9$, в среднем требуется **10 обращений**.
    - _Интуитивное понимание:_ Если стол почти пуст ($\alpha=0.5$), вы быстро найдете место. Если он забит ($\alpha=0.9$), вам придется долго ходить по рядам.

### Вставка элемента (Квадратичное исследование)

1. Рассчитывается начальный индекс: `index = hash(key) % table->capacity`.
2. Создается пара в непрерывной памяти: `pair` = _ключ ($K_{size}$) + значение ($V_{size}$)_.
3. Начинается поиск свободной ячейки, используя **квадратичное исследование** (Quadratic Probing) для расчета нового индекса: $$\text{index}_{new} = (\text{index} + \text{counter}^2) \pmod{\text{capacity}}$$ (где $counter$ увеличивается с каждой итерацией).
4. Если найдена свободная ячейка (или ячейка с совпадающим ключом), пара вставляется/заменяется.

### Проблема флага "Пусто"

Чтобы определить, свободна ли ячейка, ее часто заполняют нулями. Однако, если ключ сам может быть равен нулю, возникает неоднозначность.

**Решение:** Выделение дополнительного байта памяти (флага) в начале каждой пары. Если флаг = 0, ячейка пуста; если флаг = 1 (или другое число), ячейка занята.

### Проблема Удаления

При удалении элемента (например, тройки) в цепочке исследования может возникнуть "дыра". Если затем попытаться найти последующий элемент (например, четверку), поиск наткнется на пустую ячейку (дыру) и ошибочно сообщит, что элемента нет.

**Решение:**

1. **Пересчет хэшей** для последующих элементов (сложно и долго).
2. Использование **флага удаления** (Tombstone): При удалении ячейка помечается специальным флагом, который означает, что ячейка **логически пуста**, но **физически занята** (и поиск должен продолжаться через нее).

## 6. Метод разрешения коллизий: Метод цепочек

**Метод цепочек** (Chaining) — в каждой ячейке массива хранится указатель на **связанный список** (`GenericList`). При коллизии новый элемент просто добавляется в конец списка, прикрепленного к этому индексу.

**Коэффициент заполнения ($\alpha$):** В методе цепочек $\alpha = \frac{size}{capacity}$ может быть больше 1. Это означает, что в каждой ячейке в среднем будет $\alpha$ элементов. В среднем, количество проверяемых элементов равно **$1 + \alpha$**.

### Структура Хеш-таблицы для Цепочек

В отличие от открытой адресации, где хранится вектор пар, здесь хранятся два вектора связанных списков:

```
typedef struct {
   Vector* keys;    // Вектор GenericList для ключей
   Vector* values;  // Вектор GenericList для значений
   // ... другие поля
} HashTable;
```

Поскольку мы используем два отдельных списка (для ключей и для значений), для поиска пары по ключу мы должны найти индекс в списке ключей, а затем взять элемент с тем же индексом из списка значений.

### Вставка элемента

1. Рассчитывается индекс: `index = hash(key) % table->capacity`.
2. Получается список ключей и список значений по этому индексу.
3. Если ключ уже есть в списке (`list_index != -1`), значение заменяется.
4. Если ключа нет, ключ и значение **добавляются в конец** соответствующих списков (`appendItem`).

## 7. Рехеширование и Универсальное Хеширование

**Рехеширование (Rehashing):** Процесс, необходимый, когда коэффициент заполнения $\alpha$ становится слишком большим (особенно в открытой адресации) или просто для увеличения размера таблицы.

1. Создается новый, более крупный массив (увеличивается `capacity`).
2. Для **ВСЕХ** элементов старой таблицы пересчитываются хеши (так как `capacity` изменилась) и элементы копируются в новые ячейки в новой таблице.

**Универсальное хеширование (Universal Hashing):** Подход, где хеш-функция выбирается **случайно** из заранее определенного множества хеш-функций (например, $\text{h}_{ab}(k) = ((ak + b) \pmod p) \pmod m$). Это гарантирует, что вероятность коллизии для любой пары ключей будет невысокой.

**Идеальное хеширование (Perfect Hashing):** Структура, в которой коллизий вообще нет. Реализуется путем создания **двухуровневой** хеш-таблицы: в каждой ячейке основной таблицы находится еще одна хеш-таблица. Размер второй таблицы должен быть пропорционален квадрату числа ключей в данной ячейке ($n_j^2$).

---

Для лучшего понимания работы методов разрешения коллизий, представьте **библиотекаря (хеш-функцию)**, который пытается найти место для новой книги (ключ-значение) на полке (массиве):

|Метод|Аналогия|Что происходит при коллизии?|
|:--|:--|:--|
|**Открытая адресация**|На каждую книгу — строго одна ячейка на полке.|Если назначенное место занято, библиотекарь начинает искать свободное место рядом (по квадратичной схеме), пока не найдет пустую ячейку.|
|**Метод цепочек**|Каждая ячейка на полке может содержать крючок, к которому прикреплены связки (цепочки) книг.|Если назначенное место занято, библиотекарь просто добавляет новую книгу в конец связки, прикрепленной к этому месту.|