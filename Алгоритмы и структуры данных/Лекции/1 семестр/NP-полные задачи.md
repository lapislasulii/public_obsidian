[[Презентация лекции NP-полные задачи]]
### 1. Вспомним об О-нотации

**О-нотация** — это инструмент для описания временной и пространственной сложности алгоритмов, позволяющий оценить их поведение при росте объема входных данных $N$.

- **Типичные сложности:** $O(1)$, $O(\log N)$, $O(N)$, $O(N \log N)$, $O(N^2)$, $O(2^N)$, $O(N!)$.
- На прошлых лекциях разбирались эффективные сортировки со сложностью $O(N \log N)$, теперь фокус смещается на задачи со сложностью **$O(N^2)$ и выше**.

### 2. Примеры роста сложности: Задача о транзакциях

Для иллюстрации того, как добавление одного вложенного цикла катастрофически увеличивает время выполнения, рассматривается задача поиска парных транзакций на фонде (сумма которых равна 0).

- **Поиск пар ($O(N^2)$):** Реализуется через два вложенных цикла. При $1000$ итераций выполнение занимает около **1 секунды**.
- **Поиск трех транзакций ($O(N^3)$):** Добавляется третий вложенный цикл. Время выполнения для того же объема данных возрастает до **16 минут**.
- **Поиск пяти транзакций ($O(N^5)$):** Пять вложенных циклов превращают время ожидания в **31 год**.
- **Поиск произвольного количества транзакций ($O(N^N)$):** Если ограничений на число элементов в сумме нет, сложность становится экспоненциальной. Для 1000 итераций время составит примерно $10^{3000}$ лет (что наглядно иллюстрируется слайдом со скелетом).

### 3. Оптимизация и переход к факториалу

Сложность $O(N^N)$ можно оптимизировать, если учитывать, что комбинация индексов (например, 0-4 и 4-0) по абсолютным значениям идентична и нам не нужно проверять числа, которые были обработаны ранее.

- Если начинать каждый следующий цикл со следующего элемента (индексы $i$, $i+1$, $i+2 \dots$), количество итераций сокращается: $N \times (N-1) \times (N-2) \dots \times 1$.
- Итоговая сложность такой оптимизации — **$O(N!)$**. Хотя это лучше, чем $N^N$, график все равно стремительно уходит вверх, делая задачу нерешаемой для больших $N$ за разумное время.

### 4. NP-полные задачи и Машинное обучение

**NP-полные задачи** — это задачи, реализация которых методом полного перебора занимает тысячи лет на больших данных. В современном программировании и машинном обучении (ML) такие задачи встречаются повсеместно.

**Примеры задач, требующих перебора:**

1. **Подбор гиперпараметров** для модели (поиск наилучших настроек «черного ящика»).
2. **Отбор признаков** (feature selection) — определение того, какие входные данные (например, рост, вес, пол) больше всего влияют на результат.
3. **Обучение ансамблевых моделей**.
4. **Кластеризация данных**.
5. **Генетические алгоритмы**.

В реальной практике, если нельзя найти аналитическое решение, часто используют **Brute force** (полный перебор) или случайный перебор, смирившись с временными затратами.

### 5. Практическая задача: Кластеризация

Задача заключается в разбиении массива целых чисел на **два кластера** так, чтобы минимизировать метрику близости к среднему значению (MSE — среднеквадратичную ошибку).

- **Идея решения:** Сгенерировать все возможные комбинации («маски») распределения элементов по двум кластерам.
- **Сложность:** Для 2 кластеров и $N$ элементов количество комбинаций составляет **$2^N$**. Если кластеров будет 3, сложность вырастет до $3^N$.
- **Метрика (Score):** Сумма разностей каждого элемента и центра его кластера (среднего значения). Чем меньше score, тем лучше разбиение.

### 6. Реализация через Генератор (ProductIterator)

Для эффективного перебора комбинаций без выделения огромного объема памяти под все маски сразу, используется паттерн **итератор (генератор)**.

- **Структура `ProductIterator`:** Хранит массив индексов (текущую маску), флаг завершения (`done`) и доступные элементы (0 и 1 для двух кластеров).
- **Функция `incrementIteration`:** Работает по принципу побитового сложения в столбик. Она увеличивает правый «бит» маски; при достижении максимума происходит переполнение и перенос в следующий разряд, а текущий обнуляется.
- **Преимущество:** Мы не храним $2^N$ векторов в памяти, а вычисляем следующую маску «на лету» по запросу `nextIteration`.

### 7. Анализ итоговой сложности алгоритма

Основной цикл программы выполняет следующие действия:

1. **while (!iter->done):** выполняется **$O(2^N)$** раз.
2. **Получение маски (`next`):** $O(N)$.
3. **Распределение по кластерам:** $O(N)$.
4. **Подсчет метрики:** $O(N)$.
5. **Итоговая сложность:** Примерно **$O(N \cdot 2^N)$** (или $O(N^2 \cdot 2^N)$ при неоптимальном создании векторов), что делает алгоритм применимым только для небольших массивов (до 15–20 элементов).

---

**Аналогия для понимания:** Представьте, что вам нужно подобрать код к сейфу. Если у вас 2 цифры в коде, вы подберете его быстро. Но если длина кода увеличивается, количество комбинаций растет так стремительно, что скоро вам не хватит и всей жизни Вселенной, чтобы просто перебрать варианты. Это и есть суть **NP-сложности** — «стена», в которую упираются алгоритмы при попытке решить задачу в лоб.