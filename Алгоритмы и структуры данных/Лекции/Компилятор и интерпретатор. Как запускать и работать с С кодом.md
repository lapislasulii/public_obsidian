[[Презентация лекции Компилятор и Интерпретатор, работа с С]]

**I. Введение и Трансляторы**

1. **Тема лекции:** Вторая лекция по курсу "Алгоритмы и структуры данных" посвящена компилятору и интерпретатору, а также тому, как запускать и работать с кодом на языке C.
2. **Открытый вопрос:** Обсуждалось, что такое LLM (Large Language Model) — транслятор, компилятор или интерпретатор. Лектор отметил, что после лекции студенты смогут лучше ответить на этот вопрос.
3. **Трансляторы (Translators):** Транслятор — это программа или техническое средство, которое принимает программный код на одном языке (например, C) и выдает программный код, например, машинный.
    - **Виды трансляторов:** Компиляторы и Интерпретаторы.
    - **Логика включения:** Транслятор — это либо компилятор, либо интерпретатор. Каждая такая программа является транслятором.

**II. Исторический контекст**

- **Перфокарты:** Использовались бухгалтерскими машинами (табуляторами) и компьютерами первого поколения в 1920–1950-х годах как основной носитель для хранения и обработки данных. Одна перфокарта могла хранить до 80 байт.
- **Гигабайт информации** на перфокартах весил бы примерно 22 тонны.
- Процесс работы включал написание кода (например, на Фортране), компиляцию в байт-код, перенос информации на перфокарты и запуск.
- По своей сути, процесс обработки перфокарт — это **интерпретатор**, так как он принимает входные данные/последовательность и интерпретирует их для получения других данных/информации.

**III. Интерпретатор**

- **Принцип работы:** Интерпретатор запускается (например, `% python`), принимает интерпретируемое выражение (например, `>>> print(1)`) и выдает результат интерпретации (например, `1`).
- **Примеры:** CPython, JavaScript, BASIC.
- **Интерпретаторы для Python:**
    - **CPython (дефолтный):** Компилирует в байт-код, который затем выполняется в PVM (Python Virtual Machine). Это самый распространенный интерпретатор, обладающий максимальной совместимостью и большой экосистемой библиотек. Минусы: медленный (нет JIT) и имеет ограничения GIL.
    - **PyPy:** JIT-компилятор, который в процессе работы переводит байт-код в машинный код. Он быстрее CPython (в 2–5 раз в реальных задачах), но имеет более тяжелый запуск и несовместим со всеми библиотеками C.
- **Важное замечание:** IDE (Integrated Development Environment) — это среда для разработки (например, VS Code, Vim), а не компилятор или интерпретатор. IDE помогает настроить внешний вид, выбрать компилятор/интерпретатор и работать с кодом.

**IV. Компилятор и процесс компиляции**

- Лекция фокусируется на работе с **компилятором**.
    
- **Компиляторы (Обзор):** Мы будем использовать GCC (GNU Compiler Collection). При работе на Mac по умолчанию может использоваться Clang, который имеет символическую ссылку с GCC.
    
- **Этапы компиляции (4 шага):** Процесс преобразования исходного кода (`.c`, `.cpp`, `.h`) в исполняемый машинный код (`.exe`) состоит из четырех последовательных шагов.
    
    1. **Препроцессинг (Preprocessing):**
        
        - **Что делает:** Подставляет содержимое `#include`, разворачивает макросы (`#define`, `#if`, `#elif`, `#ifdef`, `#ifndef`, `#undef`), удаляет комментарии.
        - **Выходной файл:** "Плоский" C-файл без директив препроцессора (обычно **.i** для C или **.ii** для C++). Все комментарии удаляются, поскольку они нужны только разработчикам. При подключении заголовочных файлов, например, `<stdio.h>`, в результирующий файл могут быть вставлены сотни строк.
    2. **Компиляция (Compilation):** (Самый сложный этап)
        
        - **Что делает:** Парсит preprocessed код, строит AST (Abstract Syntax Tree), генерирует промежуточное представление (IR), применяет оптимизации (O0/O1/O2/O3).
        - **Выходной файл:** Текст ассемблера (**.s** или **.asm**).
        - **Лексический анализ (Lexer):** Исходный код преобразуется в токены (лексемы). Для этого используются **регулярные выражения** (регулярки), которые определяют паттерны (например, для идентификаторов, целых чисел, операторов и т.д.).
        - **Парсинг (Parser):** Набор лексем обрабатывается набором правил для построения дерева синтаксического анализа (Syntax tree). В процессе парсинга проверяется корректность синтаксиса (например, наличие точек с запятой).
    3. **Ассемблирование (Assemble):**
        
        - **Что делает:** Переводит текст ассемблера в **машинный код**, раскладывает код по секциям (**.text**, **.data**, **.bss**, **.rodata**), добавляет таблицы символов и релокации.
        - **Выходной файл:** Объектный файл (relocatable object): **.o** на Unix-подобных системах или **.obj** на Windows. Он еще не является исполняемым.
        - **Особенности ассемблера:** В ассемблере нет понятий циклов в привычном виде, вместо них используются **условные переходы** (`B <метка_блока>`). Команды работают либо с регистрами процессора, либо используют стековую логику.
    4. **Линковка (Linking):**
        
        - **Что делает:** Склеивает набор объектников (**.o**/**.obj**) и библиотек, разрешает символы (функции/данные), выполняет релокацию адресов, добавляет стартовый код и таблицы для загрузчика ОС.
        - **Типы:** Статическая линковка (библиотека вшивается в результат, файл больше, автономность) или Динамическая линковка (подключается при запуске, файл меньше, требует динамического загрузчика).
        - **На выходе:** Исполняемый файл (ELF на Linux, Mach-O на macOS, PE/**.exe** на Windows), динамические библиотеки (**.so**, **.dylib**, **.dll**) или статические библиотеки (**.a**, **.lib**).

**V. Установка и Инструменты сборки**

- **Общие шаги с компилятором:**
    - Windows: Скачать и установить бинарники (рекомендуется проверить актуальную версию).
    - Linux: Использовать команду `sudo apt install build-essential`.
    - Mac: Использовать `brew install gcc` (при необходимости, по умолчанию работает Clang).
- **Инструменты сборки:** Используются для автоматизации процесса компиляции и запуска.
    - **Make (сборщик, который мы будем использовать):** Читает `Makefile`. `Makefile` — это отдельная инструкция, как компилировать и запускать файлы. Он содержит блок переменных (TARGET, CC, CFLAGS, SRC) и цели (targets), например, `all` (для сборки) и `run` (для запуска).

**VI. IDE, Отладка и Ошибки**

- **IDE (Интегрированная среда разработки):** Рекомендуется использовать VS Code, так как он прост. Для работы с C/C++ необходимо установить соответствующее расширение.
- **Дебаг (Отладка):** Расширения нужны в основном для дебага. Отладка позволяет ставить **точки останова** (breakpoints) и контролировать ход выполнения программы, а также просматривать значения всех переменных и констант.
- **Вывод данных:** При работе в IDE (например, VS Code), вывод из программы (`print data`) может отображаться не в **Терминале**, а в **Консоли отладки**.
- **Работа с ошибками:** Программисты пишут подробные сообщения об ошибках, и их необходимо читать и переводить, прежде чем обращаться за помощью. В IDE также важно следить за подчеркиванием кода.
    - _Особенность C:_ Если забыть точку с запятой, компилятор часто будет ругаться на следующую строку, а не на ту, где пропущено завершение выражения.

**VII. Область видимости (Scope)**

- На слайдах были представлены основные типы областей видимости в C:
    - **Глобальная область видимости:** Функции, доступные из заголовочных файлов (например, `<stdio.h>`).
    - **Локальная область видимости:** Переменные, которые видны везде ниже их объявления в пределах функции (`main`).
    - **Область видимости переменной внутри цикла/условия:** Переменная, объявленная внутри тела цикла (`for`), не существует за пределами этого цикла.
- Пример некорректного использования переменной `i`, объявленной в цикле, вне его тела, приводит к ошибке "use of undeclared identifier 'i'".