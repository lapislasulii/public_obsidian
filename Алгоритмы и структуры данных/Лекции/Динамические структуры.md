[[Презентация лекции Динамические структуры]]
## I. Динамические структуры данных и асимптотика

Лекция посвящена динамическим структурам данных, таким как **массив**, **связный список** (`LinkedList`) и **двусвязный список** (`Double LinkedList`).

### Интуитивное сравнение структур

Выбор оптимальной структуры данных зависит от задачи.

|Структура|Описание|Примеры задач|
|:--|:--|:--|
|**Массив** (`Array`)|Элементы расположены в памяти **подряд**.|Хранение и быстрый доступ к температуре по регионам, где нужен быстрый доступ по индексу.|
|**Связный список** (`LinkedList`)|Элементы расположены **отдельно** в памяти, и каждый элемент содержит указатель на следующий.|Реализация очереди задач, где задачи часто поступают в конец и могут изыматься (удаляться) с двух концов.|

### Основные понятия асимптотики (O большое)

**Асимптотика** (O-нотация) — это верхняя граница ограничения зависимости роста времени выполнения алгоритма от количества входных данных (N).

**Интуитивное понимание:** Асимптотика показывает, насколько сильно замедлится программа при увеличении объема входных данных.

- **O(1) (Константное время):** Время выполнения **не зависит** от количества входных данных. Операция выполняется "за один такт" (мгновенно).
    - _Пример:_ Получение элемента по известному индексу в массиве.
- **O(N) (Линейное время):** Время выполнения **прямо пропорционально** количеству входных данных N. Если данных в 2 раза больше, времени потребуется в 2 раза больше.
    - _Пример:_ Поиск элемента по значению или проход по всем элементам связного списка.

### Сравнение производительности и памяти

|Операция|Array (Массив)|LinkedList (Связный список)|Double LinkedList (Двусвязный список)|
|:--|:--|:--|:--|
|**index[i] (Доступ по индексу)**|O(1)|O(N)|O(N)|
|**index, index[-1] (Доступ к концам)**|O(1)|O(1)|O(1)|
|**append (Добавление в конец)**|O(N), O*(1) (амортизированное)|O(1)|O(1)|
|**pop(0), pop(-1) (Удаление с концов)**|O(N), O*(1)|O(1), O(N)|O(1)|
|**size (Размер)**|$N \times \text{sizeof(el)} + 12 \text{ bytes}$|$N \times 16 + 8 \text{ bytes}$|$N \times 24 + 8 \text{ bytes}$|

**Почему массив быстр по индексу?** В массиве адреса последовательны, и можно простой арифметикой рассчитать адрес нужной ячейки памяти. **Почему список дорог по индексу?** Элементы в списке расположены в памяти рандомно, и для поиска элемента нужно перебирать их один за другим, следуя указателям. **Цена за скорость:** Связный список требует больше памяти на хранение указателей (8 байт на указатель). Односвязный список хранит указатель на следующее значение и само значение (16 байт на элемент), а двусвязный хранит указатели на предыдущий и следующий элементы, а также значение (24 байта).

## II. Реализация задачи: Сглаживание временного ряда

Лекция рассматривает задачу **сглаживания временного ряда средним значением**.

### Концепция сглаживания

**Сглаживание окном** — метод обработки сырых данных (например, частот звука или котировок акций), чтобы убрать шумы и сделать ряд более плавным.

- **Гиперпараметр (window_size):** Размер окна — это настройка метода, которая влияет на степень сглаживания. Чем больше окно, тем плавнее результат.
    - **Интуитивное понимание гиперпараметра:** Это регулятор в "черном ящике" алгоритма, который позволяет подогнать метод обработки под конкретный тип данных (звук, акции и т.д.).
- **Механизм:** Цикл проходит по массиву, и для каждого среза (окна) фиксированного размера вычисляется среднее значение, которое записывается в выходной массив.

### Логические шаги реализации и проблемы C

Для реализации функции чтения данных (`read_array`) и сглаживания (`smoothV1`) необходимо следовать логическим шагам:

1. Определить логические шаги (псевдокод).
2. Задуматься.
3. Реализовать.
4. Задуматься.
5. Придумать тесты.
6. Задуматься.
7. Реализовать тесты.
8. Задуматься.

#### 1. Чтение данных из файла (`read_array`)

Поскольку файл может быть большим, чтение в C/C++ часто осуществляется **посимвольно** или **батчами (кусочками)**, а не сразу целиком.

**Процесс чтения (псевдокод):**

1. Создать массив (изначально под 1 элемент).
2. Открыть файл.
3. Пока не `EOF` (конец файла), считывать символ.
4. Если символ — пробел: преобразовать накопленную строку-число в число (`strtol`) и добавить его в массив, обнулить строку-число.
5. Иначе: добавить символ в строку-число.
6. В конце файла: проверить, осталось ли накопленное число, и добавить его.
7. Закрыть файл.

**Проблемы и решения:**

- **Динамическая память:** При каждом добавлении элемента требуется **перевыделять память** (`realloc`) для расширения массива. При этом необходимо проверять, успешно ли прошло выделение/перевыделение.
- **Типы данных:** Необходимо учитывать ограничения типа (например, `int8_t` имеет диапазон от -128 до 127), что определяет максимальный размер строки-числа (5 символов: минус, 3 цифры и завершающий `\0`).
- **Размер массива:** Функция, возвращающая указатель на массив (`int8_t* arr`), не содержит информацию о его размере. Решение: передать **указатель на переменную размера** (`size_t* arr_size`) в аргументы функции. Внутри функции размер изменяется через **разыменование** (`(*arr_size)++`).
    - **Интуитивное понимание указателя на размер:** Вместо того, чтобы передавать само число (копия), мы даем функции адрес ячейки, где лежит это число. Функция меняет число прямо по этому адресу, и изменение сохраняется после завершения функции.

**Примеры тестов:**

1. **Функциональные:** Положительные числа, отрицательные числа, смешанные, нули, несколько пробелов подряд, чужеродные символы.
2. **Граничные:** Файл не существует, пустой файл, файл только с пробелами, минимальное/максимальное значение (`-128`, `127`), выход за пределы типа (`-129`, `128`), тест на утечку памяти (1e7 чисел).

## III. Улучшение: Структура Vector (Динамический массив)

Наивная реализация чтения и сглаживания неудобна, так как требует постоянного ручного управления памятью (`malloc`, `realloc`) и отдельного хранения размера. Для решения этой проблемы вводится **структура Vector**.

### Структура Vector

Vector — это структура, инкапсулирующая управление динамическим массивом:

```
typedef struct {
 int8_t* data;      // Указатель на блок данных
 size_t size;      // Текущее количество элементов, которые записаны
 size_t capacity;  // Вместимость (выделенная память в элементах)
} Vector;
```

- **capacity vs size:** `capacity` — сколько памяти выделено (вместимость); `size` — сколько элементов фактически записано. `size` всегда меньше или равен `capacity`.
- **Операции:** Структура должна поддерживать базовые операции: создание (`createVector`), добавление (`appendVectorItem`), получение (`getVectorItem`), установка (`setVectorItem`), удаление (`popVectorItem`) и освобождение памяти (`vectorFree`).
- **Создание (`createVector`):** Требует выделения памяти как под саму структуру `Vector`, так и под блок данных `data`.

### Обобщенное программирование с `void*`

Чтобы сделать `Vector` универсальным и позволить ему хранить данные любого типа (int, double, struct Point), используется указатель **`void*`**.

**Интуитивное понимание `void*`:** Представьте `void*` как адрес дома без указания, кто в нем живет и какого он размера.

- **Что он хранит:** Просто адрес в памяти.
- **Что он не знает:** Тип данных и, соответственно, количество байт, которое они занимают.
- **Как использовать:** Чтобы прочитать или записать данные, нужно **явно привести** `void*` к конкретному типу указателя (например, `(int*)ptr`). Это сообщает компилятору, сколько байт нужно читать или писать, начиная с этого адреса.

Для поддержки обобщенного программирования структура `Vector` модифицируется, и в нее добавляется поле, хранящее размер элемента:

```
typedef struct {
 void* data;       // Указатель на блок данных (тип не определен)
 size_t elem_size; // Размер элементов в байтах (напр., sizeof(int) = 4)
 size_t size;
 size_t capacity;
} Vector;
```

- **Манипуляции памятью:** Для работы с данными используются функции копирования памяти (`memcpy`) и **указательная арифметика**.
- **Смещение по адресу:** При доступе к элементу по индексу `i` необходимо вычислить точное смещение в байтах: `((char*)vector->data + index * vector->elem_size)`.
    - Указатель `vector->data` приводится к **`char*` (указатель на 1 байт)**, чтобы гарантировать, что при смещении (арифметике) адрес будет сдвигаться ровно на один байт за раз. Затем это смещение умножается на размер элемента (`elem_size`).
    - _Интуитивное понимание смещения:_ Если каждый элемент весит 4 байта, чтобы попасть к 3-му элементу (индекс 2), нужно сместиться на $2 \times 4 = 8$ байт от начала.

## IV. Оптимизация сглаживания с помощью связного списка

Реализация сглаживания (`smoothV1`, `smoothV2` на базе `Vector`) неэффективна, так как на каждой итерации цикла окно заполняется заново, что является дорогостоящей операцией.

Для оптимизации процесса скользящего окна можно использовать **связный список**.

- **Связный список (`GenericList`):** Состоит из узлов (`Node`), каждый из которых имеет данные и указатель на следующий узел.
- **Оптимизация:** При сдвиге скользящего окна на один элемент нам нужно выполнить всего две дешевые операции **O(1)**:
    1. Добавить новый элемент в конец списка.
    2. Удалить самый старый элемент из начала списка (`popItem(list, 0)`).

Таким образом, вместо пересчета всего окна на каждой итерации, список используется как динамическое окно, которое позволяет быстро добавлять и удалять элементы с концов, поддерживая при этом константное время выполнения этих операций.