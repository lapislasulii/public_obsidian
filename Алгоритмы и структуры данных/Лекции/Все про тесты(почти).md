[[Презентация лекции Все про тесты(почти)]]
## 1. Введение и Статистика

Лекция посвящена вопросам тестирования алгоритмов и структур данных.
a
По первой лабораторной работе наблюдались следующие статистические данные: общее количество запусков составило 335, а общее время работы — 397 минут. Отмечается, что некоторым студентам требовалось двузначное число попыток для успешной сдачи. Первая лаба является самой лёгкой в семестре, и студентам рекомендуется "разгоняться". Начиная с текущей (второй) лабораторной работы, **сдача без тестов не получится**.

## 2. Что такое тесты и пути отладки

**Автоматические тесты** — это набор сценариев вход-выход, проверяющих корректность работы алгоритмов.

Существуют три основных **пути отладки алгоритма**:

1. **Через `scanf`**: Пользователь вручную вводит переменные при каждом запуске программы, а затем выводит результат.
2. **Через запуски (константы)**: Объявление входных переменных прямо в коде (как констант), запуск и вывод результата (`printf`). Также включает использование режима отладки (дебага).
3. **Через тесты**: Использование специальных проверок, например, с помощью функции `assert`.

**Преимущества использования тестов**:

- **Ускорение разработки**: Автоматизированные тесты выполняются гораздо быстрее ручных проверок, что сокращает цикл разработки ПО.
- **Сокращение затрат**: Автоматизация устраняет необходимость в рутинных действиях, экономя время и ресурсы тестировщиков.
- **Повышение качества**: Помогают находить ошибки на ранних этапах и гарантируют, что новый функционал работает корректно, а старый — не сломался.
- **Исключение человеческого фактора**: Программы выполняют тесты единообразно и не подвержены усталости, невнимательности или стрессу.

## 3. Классификация и виды тестов

Тесты часто структурируются в виде пирамиды:

|Уровень (Снизу вверх)|Название|Описание|
|:--|:--|:--|
|**Unit tests**|**Юнит-тесты**|Маленькая, **независимая единица** (функция или метод).|
|**Component tests**|**Компонентные тесты**|Тестирование логической единицы, состоящей из нескольких классов, функций или слоёв (например, один независимый компонент).|
|**Integration tests**|**Интеграционные тесты**|Тестирование взаимодействия нескольких компонентов (например, взаимодействие сервисов или БД).|
|**System tests**|**Системные тесты**|Тестирование производительности, времени, памяти.|
|**Manual tests**|**Ручное тестирование**|Проверка вручную.|
|Дополнительный вид|**End-to-End tests (E2E)**|Тестирование полноценных пользовательских сценариев, имитирующее действия пользователя (например, через Selenium).|

**Виды тестов, которые будут использоваться в курсе**:

1. **Функциональные тесты:** Проверяют, правильно ли алгоритм решает задачу на ожидаемых входных данных (например, сортировка: вход `→ выход`).
2. **Граничные случаи:** Проверяют входные данные на границах допустимых значений, включая пустые входные данные `([])` или минимальные (один элемент).
3. **Стресс-тесты (Нагрузочные):** Генерируются случайные или наихудшие входные данные (например, `QuickSort` на отсортированном массиве).
4. **Тестирование эффективности:** Замеряется время выполнения для входов разного размера (относится ко второй половине курса, когда будет изучаться асимптотика).

**Критерии "хороших" тестов**:

- **Автоматизируемые**.
- **Повторяемые**.
- **Изолированные**: Один тест должен выполнять только одну проверку.
- **Понятные**: Легко читать.

## 4. Организация тестов на курсе

В курсе используется следующая структура файлов для тестирования:

1. **Заголовочный файл `*.h`**: Содержит объявления функций (например, `Vector* vectorCreate(size_t elem_size)`).
2. **Исполняемый файл `*.c`**: Содержит реализации функций.
3. **Файл тестов `tests.c`**: Отдельный файл для написания тестов, который включает библиотеку `assert.h` и заголовочный файл с тестируемыми функциями (например, `#include "my_file.h"`).

## 5. Примеры тестирования

### 5.1. Тестирование функции-калькулятора

Пример функции `float calculator(short int a, short int b, char symbol)`.

**Функциональные тесты:** Проверка корректной работы каждого оператора:

1. `1 + 1` (проверяем знак `+`).
2. `1 - 1` (проверяем знак `-`).
3. `1 * 1` (проверяем знак `*`).
4. `1 / 1` (проверяем знак `/`).
5. Проверка ветки `default` (неизвестный символ).

**Граничные тесты:** Учитывая, что входные данные имеют тип `short int` (диапазон [-32768, 32767]).

- **Переполнение при сложении:** `32767 + 1` → ожидаем `32768.0`.
- **Переполнение при вычитании:** `-32768 - 1` → ожидаем `-32769.0`.
    - _Важно:_ При проверке сложения/вычитания на границах необходимо учитывать, что происходит сначала: арифметическая операция или преобразование типов к `float`, так как если сначала происходит сложение `short int`, может произойти переполнение и непредсказуемый результат.
- **Точность при умножении:** `32767 * 32767`. Число `1073676289.0` (результат умножения) может не пройти проверку из-за **недостаточной точности `float`**.
- **Деление:** Проверка деления на ноль (`5 / 0`, `0 / 5`, `0 / 0`).
- **Неверный оператор:** Проверка произвольного символа (`'@'`) или специального символа (`'\0'`).

### 5.2. Тестирование функции подсчета делителей

Пример функции `int countDivisorsOfNumber(int num)`.

**Функциональные тесты:**

1. Положительное число (например, `6` → 4 делителя).
2. Простое число (например, `5` → 2 делителя).
3. Отрицательное число (например, `-6` → 8 делителей), так как для отрицательных чисел количество делителей удваивается.
4. Большое положительное число (например, `100` → 9 делителей).

**Граничные случаи:**

1. Число `0` (→ 0 делителей).
2. Число `1` (→ 1 делитель).
3. Максимальное число типа `int` (например, `2147483647`), которое является простым (→ 2 делителя).

**Нагрузочные (стресс) тесты:**

- Проверка времени выполнения для максимального числа `2147483647` (требование: `< 1 сек`). Изначально код без оптимизации мог выполняться около 4 секунд.

**Код после фиксов:** Для улучшения производительности и корректной обработки чисел функция оптимизируется: делители ищутся только до корня из числа (`sqrt(num)`) с учетом отрицательных чисел.

## 6. Применение в лабораторных работах (Спойлер)

Студенты будут реализовывать **динамический массив (Вектор)** и **связанный список**.

### 6.1. Сравнение массива и связанного списка

- **Массив (Динамический):** Элементы идут последовательно в памяти. Это обеспечивает **быстрое получение по индексу** (смещение указателя с помощью простой арифметики). Основная проблема — сложно выделить большой последовательный кусок памяти.
- **Связанный список (Однонаправленный):** Каждый элемент (узел/нода) содержит указатель на следующий элемент (`next`), и элементы могут находиться в произвольных местах памяти. Это позволяет выделять любое количество элементов, но усложняет индексирование.

Вектор (динамический массив) будет иметь функции, такие как `vectorCreate`, `vectorAppend`, `vectorGet`, `vectorSet` и другие.

### 6.2. Планирование тестов для функций Вектора

В динамическом массиве важно отслеживать:

- **Capacity (вместимость):** Объем выделенной памяти.
- **Size (размер):** Количество добавленных элементов.

#### **`vectorCreate(size_t elem_size)`**

- **Функциональные:** Проверка создания вектора для хранения элементов разных типов (`int`, `float/double`, `char`, `bool`, `char*`, `Vector*`).
- **Граничные:** Передача `size_t == 0`. Передача большого размера элемента (проверка, что память под него может быть выделена).

#### **`vectorAppend(Vector* vector, void* el)`**

- **Функциональные:**
    - Добавление 1 элемента, добавление 2-7 элементов.
    - Проверка увеличения `capacity` и `size` (тестирование механизма **релокации памяти**, который срабатывает при заполнении текущей `capacity`).
    - Добавление элементов разных типов.
- **Граничные:**
    - Передача `NULL` как вектора.
    - Передача `NULL` как значения.
    - Передача другого типа как значения (например, `double` в вектор, созданный для `int`. Должна быть ошибка, так как `void*` не проверяет тип).

#### **`vectorGet(Vector* vector, size_t index)`**

(Это уже не чистый юнит-тест, так как зависит от работы `vectorAppend`).

- **Функциональные:**
    - Проверка получения элемента сразу после `append`.
    - Проверка получения всех элементов после добавления нескольких.
    - Проверка получения элементов после увеличения `capacity`.
- **Граничные:**
    - Получение последнего элемента.
    - Получение на пустом векторе (должен возвращаться `NULL`).
    - Передача `NULL` вместо вектора.
    - Получение за пределами `size` (должен возвращаться `NULL`. Если это не проверить, можно получить непредсказуемое значение из памяти).

#### **`vectorSet(Vector* vector, int index, void* value)`**

- **Функциональные:**
    - `append` и после `set` (замена).
    - Замена всех элементов.
    - Проверка замены после увеличения/уменьшения `capacity`.
- **Граничные:**
    - На пустом векторе.
    - `NULL` вместо вектора или значения.
    - Вставить на `index == 0`.
    - Вставить на пределе `size` и за пределом `size`.