[[Презентация лекции Основа С синтаксиса]]
### I. Функции и процедуры

1. **Определение:** Функция или процедура — это некоторый вспомогательный алгоритм, представляющий собой именованный блок или кусок кода.
2. **Отличие функции от процедуры:** Функция, как правило, **возвращает** некоторое значение, в то время как процедура обычно ничего не возвращает.
3. **Общий вид функции:** Функция состоит из типа возвращаемого значения, имени функции, а также аргументов с обязательным указанием их типа.
    - **Отличие от Python:** В C обязателен явный тип возвращаемого значения, который ставится перед именем функции, и обязателен тип для каждого аргумента.
4. **Требования к коду и именованию:**
    - **Имена:** Названия функций и переменных должны быть **осмысленными**.
    - **Нарушение:** Использование неосмысленных названий (например, `А`, `B`, `C`, `ТМП`) ведет к отправке кода на доработку.
    - **Стиль:** В рамках курса используется `camelCase` (когда второе слово в названии пишется с заглавной буквы).

**Функция `main()` (Точка входа)**

1. **Обязательность:** `int main()` является **обязательной** точкой входа (entry point) для запуска программы.
2. **Процесс компиляции:** На этапе линковки компилятор сохраняет "якорь" на `main`, чтобы знать, что запускать.
3. **Ошибка:** Если в компилируемом файле отсутствует `main`, возникает ошибка "Undefined symbols for architecture...".
4. **Возвращаемое значение:** Функция `main` всегда возвращает целочисленное значение (`int`) — **код завершения программы**.
    - **0:** Означает, что функция/программа выполнилась **успешно** ("всё ок", "всё по плану").
    - **Ненулевое число (1, 2, -1):** Означает, что возникла **ошибка** или исключение. В C (в отличие от C++) нет встроенного механизма обработки исключений (`exception`), поэтому ошибки часто сигнализируются возвратом числа, отличного от нуля.

**Структура кода и комментарии**

1. **Логические блоки:** Код должен быть разделен на логические блоки (желательно не более 5-6 строк), отделенные пустой строкой. Типичные блоки в `main()` включают: инициализацию/ввод данных, основную логику и обработку/вывод результата.
2. **Комментарии:** Если комментарии используются, они должны содержать ответ на вопрос **"Зачем?"** (например, зачем возводится в степень, а не просто что происходит возведение в степень).

---

### II. Переменные, Константы и Память (Scope)

**Переменные и Константы**

1. **Типы:** Для переменных используются типы, такие как `int`, `float`, `double`, `char`.
2. **`bool`:** Тип `bool` поддерживается, начиная со стандарта C99. Если компилятор выдает ошибку, нужно убедиться, что используется подходящий стандарт (например, C17, который решает почти все проблемы). Для работы с `bool` требуется подключение `<stdbool.h>`.
3. **Константы (`const`):** Переменная, которую нельзя изменить после инициализации. Они используются для неизменяемых значений, часто в аргументах функций.

**Область видимости (Scope)**

1. **Определение:** Область видимости переменной определяется **фигурными скобками** (`{}`).
2. **Жизненный цикл:** Переменная существует ровно на время жизни конкретного блока кода, в котором она была создана. Как только логический блок завершается, все переменные, созданные в нем, уничтожаются.
3. **Пример:** Переменная `i`, объявленная в цикле `for(int i = 0; ...){...}`, не существует за пределами тела этого цикла.

**Стек, Куча и Утечки памяти**

1. **Стек (Stack):** Используется для хранения **локальных переменных** и аргументов функций. Создается и гасится быстро. Переменные помещаются в стек по мере их создания.
2. **Куча (Heap):** Используется для **динамически выделенной памяти** с помощью функций, таких как `malloc` и `calloc`. Эта память может использоваться на долгом промежутке.
3. **Утечка памяти (Memory Leak):** При динамическом выделении памяти (`malloc`) указатель на эту память помещается в Стек. Когда функция завершается, указатель (на Стеке) уничтожается, но сама память (в Куче) остается зарезервированной за процессом. Это приводит к утечке памяти.
4. **Освобождение памяти:** Для освобождения памяти, выделенной в Куче, используется функция `free(ptr)`. Функция `free` не затирает данные, но сигнализирует процессору, что память теперь свободна.

**Выход за пределы массива (Out-of-Bounds)**

1. C **не сообщает** о выходе за пределы массива.
2. **Последствия** записи за пределы массива в Стеке:
    - **"Ниндзя баг":** Перезапись значения другой используемой переменной, что приводит к непредсказуемым ошибкам, которые сложно отследить.
    - **Segmentation Failed (Segmentation Fault):** Выход за пределы Стек. Это наиболее благоприятный исход, поскольку программа немедленно ломается, и ошибку можно быстро исправить.

---

### III. Условия и Циклы

**Условия (`if` и `switch-case`)**

1. **Логика `if`:** В C **любое ненулевое число** интерпретируется как `true`. Только `0` (или `0.0`) считается `false`. Символы (например, `'a'`) также считаются `true`, поскольку их значение в Unicode не равно нулю.
2. **Синтаксис:** Если в логическом блоке используется только один стейтмент (команда, завершенная точкой с запятой), фигурные скобки можно опустить. Лектор советует всегда ставить фигурные скобки.
3. **`switch-case`:** Используется, когда нужно обработать четкий, фиксированный набор значений (например, преобразование числа в цвет).
4. **Fall-through:** Если в блоке `case` пропущен оператор `break`, выполнение переходит (проваливается) к следующему блоку `case` и выполняет его тело, пока не встретится `break` или `return`.

**Циклы**

1. **`for (;;)`:** Используется, когда заранее известно четкое число итераций. Конструкция `for (;;)` обозначает бесконечный цикл.
2. **`while (true)`:** Используется, пока условие истинно.
3. **`do {} while (true)`:** Гарантирует, что тело цикла будет выполнено **хотя бы один раз**, прежде чем будет проверено условие.
4. **Выбор цикла:** Если первое действие гарантировано (например, ввод пароля до первой ошибки), предпочтительнее использовать `do while`.

---

### IV. Указатели, Строки и Библиотеки

**Подключение библиотек и заголовочные файлы**

1. **Системные библиотеки:** Подключаются с помощью угловых скобок (например, `#include <stdio.h>`).
    - Примеры: `<stdio.h>` (для `printf`, `scanf`), `<stdlib.h>` (для `malloc`, `free`), `<string.h>` (для работы со строками), `<math.h>` (для `pow`).
2. **Кастомные файлы:** Подключаются с помощью кавычек (например, `#include "mytools.h"`). Компилятор начинает поиск таких файлов сначала в рабочей директории.
3. **Разделение кода:**
    - **Заголовочные файлы (`*.h`):** Содержат **прототипы функций** (объявления), структуры и константы.
    - **Исполняемые файлы (`*.c`):** Содержат **реализацию** (логику) функций.
    - Это разделение упрощает работу компилятора и помогает решать проблемы множественных импортов и зависимости порядка объявления.

**Указатели (Pointers)**

1. **Сущность:** Указатель — это специальный тип данных, который хранит **адрес ячейки памяти**. При выводе самого указателя вы увидите большое число — адрес.
2. **Выделение памяти:** Функции `malloc(size)` и `calloc(count, size)` резервируют память в Куче.
    - `calloc` отличается тем, что автоматически заполняет выделенную память нулями.
3. **Разыменование:** Чтобы извлечь значение из ячейки, на которую указывает указатель, используется оператор звездочки (`*arr`).
4. **Арифметика указателей:** При добавлении числа к указателю (например, `arr + 2`) адрес смещается на `число * sizeof(тип)`. Это позволяет обращаться к последовательным элементам, если указатель указывает на массив.

**Работа со строками**

1. **Структура строки:** Строка в C — это по сути массив символов (`char`).
2. **Терминатор:** Строка должна быть завершена **нулевым символом** (`\0`). Это позволяет стандартным функциям (`strlen`, `strcpy`) определять конец значимой части строки, даже если выделен большой объем памяти.
3. **Возврат строковых констант:** Разрешено возвращать строковые константы (например, `return "blue";`) из функций, поскольку они помещаются в специальную область памяти read-only, которая существует в течение всей жизни программы.
4. **Полезные функции** (из `<string.h>`):
    - `strlen`: Возвращает длину строки (без учета `\0`).
    - `strcpy`/`strncpy`: Копирует строку.
    - `strcat`/`strncat`: Добавляет строку.
    - `sprintf`: Форматирует строку и записывает ее в буфер.
    - `strcmp`/`strncmp`: Сравнивает две строки.

---

### V. Сдача лабораторных работ (Лабы)

1. **Общая информация:** Все материалы, гайды ("Как проходит защита", "Подсказка по исправлению проблем с git") и таблица успеваемости находятся в репозитории организации на GitHub.
2. **Вопросы менторам:** Вопросы следует создавать в **дискуссионном разделе** на GitHub, а затем отправлять ссылку на дискуссию ментору.
3. **Процесс сдачи (GitHub Flow)**:
    - Склонировать репозиторий.
    - Создать ветку. **Название ветки** должно соответствовать формату, указанному в таблице успеваемости (например, `lab-1-intro`), чтобы бот мог его распознать.
    - Решить лабораторную.
    - Добавить изменения в индекс (`git add .`) и зафиксировать (`git commit`).
    - Запушить изменения в удаленный репозиторий.
    - Создать **Pull Request (PR)** — запрос на слияние.
    - Назначить преподавателя (ревьюером).
4. **Результаты проверки (Светофор)**:
    - **Change Request (Красный):** Ментор не принял решение и требует внести правки. Запрос отправляется в конец очереди на проверку.
    - **Approve (Желтый):** Все сделано "ок" и предварительно принято. Необходимо прийти на **очную защиту**.
    - **Merge Request (Зеленый):** Все принято, баллы выставлены. Если ментор сразу принял лабу, на защиту идти **не нужно**.
5. **Сроки:** Первая лабораторная будет опубликована в ближайшее время, и на ее выполнение будет дано примерно **один месяц**.